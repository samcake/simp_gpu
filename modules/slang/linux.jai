//
// This file was auto-generated using the following command:
//
// jai generate.jai
//



SLANG_CLANG :: 1;

SLANG_VC :: 0;

SLANG_SNC :: 0;

SLANG_GHS :: 0;

SLANG_GCC :: 0;

SLANG_LINUX :: 1;

SLANG_WINRT :: 0;

SLANG_XBOXONE :: 0;

SLANG_WIN64 :: 0;

SLANG_X360 :: 0;

SLANG_WIN32 :: 0;

SLANG_ANDROID :: 0;

SLANG_IOS :: 0;

SLANG_OSX :: 0;

SLANG_PS3 :: 0;

SLANG_PS4 :: 0;

SLANG_PSP2 :: 0;

SLANG_WIIU :: 0;

SLANG_GCC_FAMILY :: SLANG_CLANG || SLANG_SNC || SLANG_GHS || SLANG_GCC;
SLANG_WINDOWS_FAMILY :: SLANG_WINRT || SLANG_WIN32 || SLANG_WIN64;
SLANG_MICROSOFT_FAMILY :: SLANG_XBOXONE || SLANG_X360 || SLANG_WINDOWS_FAMILY;
SLANG_LINUX_FAMILY :: SLANG_LINUX || SLANG_ANDROID;
SLANG_APPLE_FAMILY :: SLANG_IOS || SLANG_OSX;
SLANG_UNIX_FAMILY :: SLANG_LINUX_FAMILY || SLANG_APPLE_FAMILY;

SLANG_ENABLE_DXVK :: 0;
SLANG_ENABLE_VKD3D :: 0;

SLANG_ENABLE_DIRECTX :: SLANG_ENABLE_DXVK || SLANG_ENABLE_VKD3D;
SLANG_ENABLE_DXGI_DEBUG :: 0;
SLANG_ENABLE_DXBC_SUPPORT :: 0;
SLANG_ENABLE_PIX :: 0;

SLANG_HAS_EXCEPTIONS :: 1;

SLANG_HAS_MOVE_SEMANTICS :: 1;
SLANG_HAS_ENUM_CLASS :: 1;

SLANG_PROCESSOR_X86_64 :: 1;

SLANG_PROCESSOR_ARM :: 0;

SLANG_PROCESSOR_ARM_64 :: 0;

SLANG_PROCESSOR_X86 :: 0;

SLANG_PROCESSOR_POWER_PC :: 0;

SLANG_PROCESSOR_POWER_PC_64 :: 0;

SLANG_PROCESSOR_FAMILY_X86 :: SLANG_PROCESSOR_X86_64 | SLANG_PROCESSOR_X86;
SLANG_PROCESSOR_FAMILY_ARM :: SLANG_PROCESSOR_ARM | SLANG_PROCESSOR_ARM_64;
SLANG_PROCESSOR_FAMILY_POWER_PC :: SLANG_PROCESSOR_POWER_PC_64 | SLANG_PROCESSOR_POWER_PC;

SLANG_PTR_IS_64 :: SLANG_PROCESSOR_ARM_64 | SLANG_PROCESSOR_X86_64 | SLANG_PROCESSOR_POWER_PC_64;

SLANG_PTR_IS_32 :: SLANG_PTR_IS_64 ^ 1;

SLANG_LITTLE_ENDIAN :: 1;
SLANG_UNALIGNED_ACCESS :: 1;

SLANG_BIG_ENDIAN :: 0;

SLANG_FACILITY_WIN_GENERAL :: 0;
SLANG_FACILITY_WIN_INTERFACE :: 4;
SLANG_FACILITY_WIN_API :: 7;

SLANG_FACILITY_BASE :: 0x200;

SLANG_FACILITY_CORE :: SLANG_FACILITY_BASE;

SLANG_FACILITY_INTERNAL :: SLANG_FACILITY_BASE + 1;

SLANG_FACILITY_EXTERNAL_BASE :: 0x210;

SLANG_OK :: 0;

SLANG_UNBOUNDED_SIZE :: 18446744073709551615;

SLANG_API_VERSION :: 0;

/*!
@mainpage Introduction

API Reference: slang.h

@file slang.h
*/
SlangUInt32 :: u32;
SlangInt32 :: s32;

SlangInt :: s64;
SlangUInt :: u64;

SlangSSizeT :: s64;
SlangSizeT :: u64;

SlangBool :: bool;

/*!
@brief Severity of a diagnostic generated by the compiler.
Values come from the enum below, with higher values representing more severe
conditions, and all values >= SLANG_SEVERITY_ERROR indicating compilation
failure.
*/
SlangSeverityIntegral :: s32;
SlangSeverity :: enum SlangSeverityIntegral {
    DISABLED :: 0;
    NOTE     :: 1;
    WARNING  :: 2;
    ERROR    :: 3;
    FATAL    :: 4;
    INTERNAL :: 5;

    SLANG_SEVERITY_DISABLED :: DISABLED;
    SLANG_SEVERITY_NOTE     :: NOTE;
    SLANG_SEVERITY_WARNING  :: WARNING;
    SLANG_SEVERITY_ERROR    :: ERROR;
    SLANG_SEVERITY_FATAL    :: FATAL;
    SLANG_SEVERITY_INTERNAL :: INTERNAL;
}

SlangDiagnosticFlags :: s32;
SLANG_DIAGNOSTIC_FLAG :: enum u32 {
    VERBOSE_PATHS            :: 1;
    TREAT_WARNINGS_AS_ERRORS :: 2;

    SLANG_DIAGNOSTIC_FLAG_VERBOSE_PATHS            :: VERBOSE_PATHS;
    SLANG_DIAGNOSTIC_FLAG_TREAT_WARNINGS_AS_ERRORS :: TREAT_WARNINGS_AS_ERRORS;
}

SlangBindableResourceIntegral :: s32;
SlangBindableResourceType :: enum SlangBindableResourceIntegral {
    NON_BINDABLE   :: 0;
    TEXTURE        :: 1;
    SAMPLER        :: 2;
    UNIFORM_BUFFER :: 3;
    STORAGE_BUFFER :: 4;

    SLANG_NON_BINDABLE   :: NON_BINDABLE;
    SLANG_TEXTURE        :: TEXTURE;
    SLANG_SAMPLER        :: SAMPLER;
    SLANG_UNIFORM_BUFFER :: UNIFORM_BUFFER;
    SLANG_STORAGE_BUFFER :: STORAGE_BUFFER;
}

/* NOTE! To keep binary compatibility care is needed with this enum!

* To add value, only add at the bottom (before COUNT_OF)
* To remove a value, add _DEPRECATED as a suffix, but leave in the list

This will make the enum values stable, and compatible with libraries that might not use the
latest enum values.
*/
SlangCompileTargetIntegral :: s32;
SlangCompileTarget :: enum SlangCompileTargetIntegral {
    TARGET_UNKNOWN                  :: 0;
    TARGET_NONE                     :: 1;
    GLSL                            :: 2;
    GLSL_VULKAN_DEPRECATED          :: 3;
    GLSL_VULKAN_ONE_DESC_DEPRECATED :: 4;
    HLSL                            :: 5;
    SPIRV                           :: 6;
    SPIRV_ASM                       :: 7;
    DXBC                            :: 8;
    DXBC_ASM                        :: 9;
    DXIL                            :: 10;
    DXIL_ASM                        :: 11;
    C_SOURCE                        :: 12;
    CPP_SOURCE                      :: 13;
    HOST_EXECUTABLE                 :: 14;
    SHADER_SHARED_LIBRARY           :: 15;

    SHADER_HOST_CALLABLE            :: 16;

    CUDA_SOURCE                     :: 17;
    PTX                             :: 18;
    CUDA_OBJECT_CODE                :: 19;
    OBJECT_CODE                     :: 20;
    HOST_CPP_SOURCE                 :: 21;
    HOST_HOST_CALLABLE              :: 22;
    CPP_PYTORCH_BINDING             :: 23;
    METAL                           :: 24;
    METAL_LIB                       :: 25;
    METAL_LIB_ASM                   :: 26;
    HOST_SHARED_LIBRARY             :: 27;
    WGSL                            :: 28;
    WGSL_SPIRV_ASM                  :: 29;
    WGSL_SPIRV                      :: 30;
    TARGET_COUNT_OF                 :: 31;

    SLANG_TARGET_UNKNOWN                  :: TARGET_UNKNOWN;
    SLANG_TARGET_NONE                     :: TARGET_NONE;
    SLANG_GLSL                            :: GLSL;
    SLANG_GLSL_VULKAN_DEPRECATED          :: GLSL_VULKAN_DEPRECATED;
    SLANG_GLSL_VULKAN_ONE_DESC_DEPRECATED :: GLSL_VULKAN_ONE_DESC_DEPRECATED;
    SLANG_HLSL                            :: HLSL;
    SLANG_SPIRV                           :: SPIRV;
    SLANG_SPIRV_ASM                       :: SPIRV_ASM;
    SLANG_DXBC                            :: DXBC;
    SLANG_DXBC_ASM                        :: DXBC_ASM;
    SLANG_DXIL                            :: DXIL;
    SLANG_DXIL_ASM                        :: DXIL_ASM;
    SLANG_C_SOURCE                        :: C_SOURCE;
    SLANG_CPP_SOURCE                      :: CPP_SOURCE;
    SLANG_HOST_EXECUTABLE                 :: HOST_EXECUTABLE;
    SLANG_SHADER_SHARED_LIBRARY           :: SHADER_SHARED_LIBRARY;

    SLANG_SHADER_HOST_CALLABLE            :: SHADER_HOST_CALLABLE;

    SLANG_CUDA_SOURCE                     :: CUDA_SOURCE;
    SLANG_PTX                             :: PTX;
    SLANG_CUDA_OBJECT_CODE                :: CUDA_OBJECT_CODE;
    SLANG_OBJECT_CODE                     :: OBJECT_CODE;
    SLANG_HOST_CPP_SOURCE                 :: HOST_CPP_SOURCE;
    SLANG_HOST_HOST_CALLABLE              :: HOST_HOST_CALLABLE;
    SLANG_CPP_PYTORCH_BINDING             :: CPP_PYTORCH_BINDING;
    SLANG_METAL                           :: METAL;
    SLANG_METAL_LIB                       :: METAL_LIB;
    SLANG_METAL_LIB_ASM                   :: METAL_LIB_ASM;
    SLANG_HOST_SHARED_LIBRARY             :: HOST_SHARED_LIBRARY;
    SLANG_WGSL                            :: WGSL;
    SLANG_WGSL_SPIRV_ASM                  :: WGSL_SPIRV_ASM;
    SLANG_WGSL_SPIRV                      :: WGSL_SPIRV;
    SLANG_TARGET_COUNT_OF                 :: TARGET_COUNT_OF;
}

/* A "container format" describes the way that the outputs
for multiple files, entry points, targets, etc. should be
combined into a single artifact for output. */
SlangContainerFormatIntegral :: s32;
SlangContainerFormat :: enum SlangContainerFormatIntegral {
    NONE         :: 0;

    SLANG_MODULE :: 1;

    SLANG_CONTAINER_FORMAT_NONE         :: NONE;

    SLANG_CONTAINER_FORMAT_SLANG_MODULE :: SLANG_MODULE;
}

SlangPassThroughIntegral :: s32;
SlangPassThrough :: enum SlangPassThroughIntegral {
    NONE          :: 0;
    FXC           :: 1;
    DXC           :: 2;
    GLSLANG       :: 3;
    SPIRV_DIS     :: 4;
    CLANG         :: 5;
    VISUAL_STUDIO :: 6;
    GCC           :: 7;
    GENERIC_C_CPP :: 8;

    NVRTC         :: 9;
    LLVM          :: 10;
    SPIRV_OPT     :: 11;
    METAL         :: 12;
    TINT          :: 13;
    COUNT_OF      :: 14;

    SLANG_PASS_THROUGH_NONE          :: NONE;
    SLANG_PASS_THROUGH_FXC           :: FXC;
    SLANG_PASS_THROUGH_DXC           :: DXC;
    SLANG_PASS_THROUGH_GLSLANG       :: GLSLANG;
    SLANG_PASS_THROUGH_SPIRV_DIS     :: SPIRV_DIS;
    SLANG_PASS_THROUGH_CLANG         :: CLANG;
    SLANG_PASS_THROUGH_VISUAL_STUDIO :: VISUAL_STUDIO;
    SLANG_PASS_THROUGH_GCC           :: GCC;
    SLANG_PASS_THROUGH_GENERIC_C_CPP :: GENERIC_C_CPP;

    SLANG_PASS_THROUGH_NVRTC         :: NVRTC;
    SLANG_PASS_THROUGH_LLVM          :: LLVM;
    SLANG_PASS_THROUGH_SPIRV_OPT     :: SPIRV_OPT;
    SLANG_PASS_THROUGH_METAL         :: METAL;
    SLANG_PASS_THROUGH_TINT          :: TINT;
    SLANG_PASS_THROUGH_COUNT_OF      :: COUNT_OF;
}

/* Defines an archive type used to holds a 'file system' type structure. */
SlangArchiveTypeIntegral :: s32;
SlangArchiveType :: enum SlangArchiveTypeIntegral {
    UNDEFINED    :: 0;
    ZIP          :: 1;
    RIFF         :: 2;
    RIFF_DEFLATE :: 3;
    RIFF_LZ4     :: 4;
    COUNT_OF     :: 5;

    SLANG_ARCHIVE_TYPE_UNDEFINED    :: UNDEFINED;
    SLANG_ARCHIVE_TYPE_ZIP          :: ZIP;
    SLANG_ARCHIVE_TYPE_RIFF         :: RIFF;
    SLANG_ARCHIVE_TYPE_RIFF_DEFLATE :: RIFF_DEFLATE;
    SLANG_ARCHIVE_TYPE_RIFF_LZ4     :: RIFF_LZ4;
    SLANG_ARCHIVE_TYPE_COUNT_OF     :: COUNT_OF;
}

/*!
Flags to control compilation behavior.
*/
SlangCompileFlags :: u32;
SLANG_COMPILE_FLAG :: enum u32 {
    NO_MANGLING       :: 8;

    NO_CODEGEN        :: 16;

    OBFUSCATE         :: 32;

    NO_CHECKING       :: 0;
    SPLIT_MIXED_TYPES :: 0;

    SLANG_COMPILE_FLAG_NO_MANGLING       :: NO_MANGLING;

    SLANG_COMPILE_FLAG_NO_CODEGEN        :: NO_CODEGEN;

    SLANG_COMPILE_FLAG_OBFUSCATE         :: OBFUSCATE;

    SLANG_COMPILE_FLAG_NO_CHECKING       :: NO_CHECKING;
    SLANG_COMPILE_FLAG_SPLIT_MIXED_TYPES :: SPLIT_MIXED_TYPES;
}

/*!
@brief Flags to control code generation behavior of a compilation target */
SlangTargetFlags :: u32;
SLANG_TARGET_FLAG :: enum u32 {
    PARAMETER_BLOCKS_USE_REGISTER_SPACES :: 16;

    GENERATE_WHOLE_PROGRAM               :: 256;

    DUMP_IR                              :: 512;

    GENERATE_SPIRV_DIRECTLY              :: 1024;

    SLANG_TARGET_FLAG_PARAMETER_BLOCKS_USE_REGISTER_SPACES :: PARAMETER_BLOCKS_USE_REGISTER_SPACES;

    SLANG_TARGET_FLAG_GENERATE_WHOLE_PROGRAM               :: GENERATE_WHOLE_PROGRAM;

    SLANG_TARGET_FLAG_DUMP_IR                              :: DUMP_IR;

    SLANG_TARGET_FLAG_GENERATE_SPIRV_DIRECTLY              :: GENERATE_SPIRV_DIRECTLY;
}

kDefaultTargetFlags: SlangTargetFlags : xx SLANG_TARGET_FLAG.GENERATE_SPIRV_DIRECTLY;

/*!
@brief Options to control floating-point precision guarantees for a target.
*/
SlangFloatingPointModeIntegral :: u32;
SlangFloatingPointMode :: enum SlangFloatingPointModeIntegral {
    DEFAULT :: 0;
    FAST    :: 1;
    PRECISE :: 2;

    SLANG_FLOATING_POINT_MODE_DEFAULT :: DEFAULT;
    SLANG_FLOATING_POINT_MODE_FAST    :: FAST;
    SLANG_FLOATING_POINT_MODE_PRECISE :: PRECISE;
}

/*!
@brief Options to control emission of `#line` directives
*/
SlangLineDirectiveModeIntegral :: u32;
SlangLineDirectiveMode :: enum SlangLineDirectiveModeIntegral {
    DEFAULT    :: 0;

    NONE       :: 1;
    STANDARD   :: 2;
    GLSL       :: 3;

    SOURCE_MAP :: 4;

    SLANG_LINE_DIRECTIVE_MODE_DEFAULT    :: DEFAULT;

    SLANG_LINE_DIRECTIVE_MODE_NONE       :: NONE;
    SLANG_LINE_DIRECTIVE_MODE_STANDARD   :: STANDARD;
    SLANG_LINE_DIRECTIVE_MODE_GLSL       :: GLSL;

    SLANG_LINE_DIRECTIVE_MODE_SOURCE_MAP :: SOURCE_MAP;
}

SlangSourceLanguageIntegral :: s32;
SlangSourceLanguage :: enum SlangSourceLanguageIntegral {
    UNKNOWN  :: 0;
    SLANG    :: 1;
    HLSL     :: 2;
    GLSL     :: 3;
    C        :: 4;
    CPP      :: 5;
    CUDA     :: 6;
    SPIRV    :: 7;
    METAL    :: 8;
    WGSL     :: 9;
    COUNT_OF :: 10;

    SLANG_SOURCE_LANGUAGE_UNKNOWN  :: UNKNOWN;
    SLANG_SOURCE_LANGUAGE_SLANG    :: SLANG;
    SLANG_SOURCE_LANGUAGE_HLSL     :: HLSL;
    SLANG_SOURCE_LANGUAGE_GLSL     :: GLSL;
    SLANG_SOURCE_LANGUAGE_C        :: C;
    SLANG_SOURCE_LANGUAGE_CPP      :: CPP;
    SLANG_SOURCE_LANGUAGE_CUDA     :: CUDA;
    SLANG_SOURCE_LANGUAGE_SPIRV    :: SPIRV;
    SLANG_SOURCE_LANGUAGE_METAL    :: METAL;
    SLANG_SOURCE_LANGUAGE_WGSL     :: WGSL;
    SLANG_SOURCE_LANGUAGE_COUNT_OF :: COUNT_OF;
}

SlangProfileIDIntegral :: u32;
SlangProfileID :: enum SlangProfileIDIntegral {
    SLANG_PROFILE_UNKNOWN :: 0;
}

SlangCapabilityIDIntegral :: SlangInt32;
SlangCapabilityID :: enum SlangCapabilityIDIntegral {
    SLANG_CAPABILITY_UNKNOWN :: 0;
}

SlangMatrixLayoutModeIntegral :: u32;
SlangMatrixLayoutMode :: enum SlangMatrixLayoutModeIntegral {
    MODE_UNKNOWN :: 0;
    ROW_MAJOR    :: 1;
    COLUMN_MAJOR :: 2;

    SLANG_MATRIX_LAYOUT_MODE_UNKNOWN :: MODE_UNKNOWN;
    SLANG_MATRIX_LAYOUT_ROW_MAJOR    :: ROW_MAJOR;
    SLANG_MATRIX_LAYOUT_COLUMN_MAJOR :: COLUMN_MAJOR;
}

SlangStageIntegral :: SlangUInt32;
SlangStage :: enum SlangStageIntegral {
    NONE           :: 0;
    VERTEX         :: 1;
    HULL           :: 2;
    DOMAIN         :: 3;
    GEOMETRY       :: 4;
    FRAGMENT       :: 5;
    COMPUTE        :: 6;
    RAY_GENERATION :: 7;
    INTERSECTION   :: 8;
    ANY_HIT        :: 9;
    CLOSEST_HIT    :: 10;
    MISS           :: 11;
    CALLABLE       :: 12;
    MESH           :: 13;
    AMPLIFICATION  :: 14;

    PIXEL          :: 5;

    SLANG_STAGE_NONE           :: NONE;
    SLANG_STAGE_VERTEX         :: VERTEX;
    SLANG_STAGE_HULL           :: HULL;
    SLANG_STAGE_DOMAIN         :: DOMAIN;
    SLANG_STAGE_GEOMETRY       :: GEOMETRY;
    SLANG_STAGE_FRAGMENT       :: FRAGMENT;
    SLANG_STAGE_COMPUTE        :: COMPUTE;
    SLANG_STAGE_RAY_GENERATION :: RAY_GENERATION;
    SLANG_STAGE_INTERSECTION   :: INTERSECTION;
    SLANG_STAGE_ANY_HIT        :: ANY_HIT;
    SLANG_STAGE_CLOSEST_HIT    :: CLOSEST_HIT;
    SLANG_STAGE_MISS           :: MISS;
    SLANG_STAGE_CALLABLE       :: CALLABLE;
    SLANG_STAGE_MESH           :: MESH;
    SLANG_STAGE_AMPLIFICATION  :: AMPLIFICATION;

    SLANG_STAGE_PIXEL          :: PIXEL;
}

SlangDebugInfoLevelIntegral :: SlangUInt32;
SlangDebugInfoLevel :: enum SlangDebugInfoLevelIntegral {
    NONE     :: 0;
    MINIMAL  :: 1;

    STANDARD :: 2;

    MAXIMAL  :: 3;

    SLANG_DEBUG_INFO_LEVEL_NONE     :: NONE;
    SLANG_DEBUG_INFO_LEVEL_MINIMAL  :: MINIMAL;

    SLANG_DEBUG_INFO_LEVEL_STANDARD :: STANDARD;

    SLANG_DEBUG_INFO_LEVEL_MAXIMAL  :: MAXIMAL;
}

/* Describes the debugging information format produced during a compilation. */
SlangDebugInfoFormatIntegral :: SlangUInt32;
SlangDebugInfoFormat :: enum SlangDebugInfoFormatIntegral {
    DEFAULT  :: 0;
    C7       :: 1;

    PDB      :: 2;

    STABS    :: 3;
    COFF     :: 4;
    DWARF    :: 5;

    COUNT_OF :: 6;

    SLANG_DEBUG_INFO_FORMAT_DEFAULT  :: DEFAULT;
    SLANG_DEBUG_INFO_FORMAT_C7       :: C7;

    SLANG_DEBUG_INFO_FORMAT_PDB      :: PDB;

    SLANG_DEBUG_INFO_FORMAT_STABS    :: STABS;
    SLANG_DEBUG_INFO_FORMAT_COFF     :: COFF;
    SLANG_DEBUG_INFO_FORMAT_DWARF    :: DWARF;

    SLANG_DEBUG_INFO_FORMAT_COUNT_OF :: COUNT_OF;
}

SlangOptimizationLevelIntegral :: SlangUInt32;
SlangOptimizationLevel :: enum SlangOptimizationLevelIntegral {
    NONE    :: 0;
    DEFAULT :: 1;

    HIGH    :: 2;
    MAXIMAL :: 3;

    SLANG_OPTIMIZATION_LEVEL_NONE    :: NONE;
    SLANG_OPTIMIZATION_LEVEL_DEFAULT :: DEFAULT;

    SLANG_OPTIMIZATION_LEVEL_HIGH    :: HIGH;
    SLANG_OPTIMIZATION_LEVEL_MAXIMAL :: MAXIMAL;
}

SlangEmitSpirvMethod :: enum u32 {
    DEFAULT  :: 0;
    VIA_GLSL :: 1;
    DIRECTLY :: 2;

    SLANG_EMIT_SPIRV_DEFAULT  :: DEFAULT;
    SLANG_EMIT_SPIRV_VIA_GLSL :: VIA_GLSL;
    SLANG_EMIT_SPIRV_DIRECTLY :: DIRECTLY;
}
// All compiler option names supported by Slang.

CompilerOptionName :: enum s32 {
    MacroDefine                      :: 0;
    DepFile                          :: 1;
    EntryPointName                   :: 2;
    Specialize                       :: 3;
    Help                             :: 4;
    HelpStyle                        :: 5;
    Include                          :: 6;
    Language                         :: 7;
    MatrixLayoutColumn               :: 8;
    MatrixLayoutRow                  :: 9;
    ZeroInitialize                   :: 10;
    IgnoreCapabilities               :: 11;
    RestrictiveCapabilityCheck       :: 12;
    ModuleName                       :: 13;
    Output                           :: 14;
    Profile                          :: 15;
    Stage                            :: 16;
    Target                           :: 17;
    Version                          :: 18;
    WarningsAsErrors                 :: 19;
    DisableWarnings                  :: 20;
    EnableWarning                    :: 21;
    DisableWarning                   :: 22;
    DumpWarningDiagnostics           :: 23;
    InputFilesRemain                 :: 24;
    EmitIr                           :: 25;
    ReportDownstreamTime             :: 26;
    ReportPerfBenchmark              :: 27;
    ReportCheckpointIntermediates    :: 28;
    SkipSPIRVValidation              :: 29;
    SourceEmbedStyle                 :: 30;
    SourceEmbedName                  :: 31;
    SourceEmbedLanguage              :: 32;
    DisableShortCircuit              :: 33;
    MinimumSlangOptimization         :: 34;
    DisableNonEssentialValidations   :: 35;
    DisableSourceMap                 :: 36;
    UnscopedEnum                     :: 37;
    PreserveParameters               :: 38;

    Capability                       :: 39;
    DefaultImageFormatUnknown        :: 40;
    DisableDynamicDispatch           :: 41;
    DisableSpecialization            :: 42;
    FloatingPointMode                :: 43;
    DebugInformation                 :: 44;
    LineDirectiveMode                :: 45;
    Optimization                     :: 46;
    Obfuscate                        :: 47;

    VulkanBindShift                  :: 48;

    VulkanBindGlobals                :: 49;
    VulkanInvertY                    :: 50;
    VulkanUseDxPositionW             :: 51;
    VulkanUseEntryPointName          :: 52;
    VulkanUseGLLayout                :: 53;
    VulkanEmitReflection             :: 54;

    GLSLForceScalarLayout            :: 55;
    EnableEffectAnnotations          :: 56;

    EmitSpirvViaGLSL                 :: 57;
    EmitSpirvDirectly                :: 58;
    SPIRVCoreGrammarJSON             :: 59;
    IncompleteLibrary                :: 60;

    CompilerPath                     :: 61;
    DefaultDownstreamCompiler        :: 62;
    DownstreamArgs                   :: 63;

    PassThrough                      :: 64;

    DumpRepro                        :: 65;
    DumpReproOnError                 :: 66;
    ExtractRepro                     :: 67;
    LoadRepro                        :: 68;
    LoadReproDirectory               :: 69;
    ReproFallbackDirectory           :: 70;

    DumpAst                          :: 71;
    DumpIntermediatePrefix           :: 72;
    DumpIntermediates                :: 73;
    DumpIr                           :: 74;
    DumpIrIds                        :: 75;
    PreprocessorOutput               :: 76;
    OutputIncludes                   :: 77;
    ReproFileSystem                  :: 78;
    SerialIr                         :: 79;
    SkipCodeGen                      :: 80;
    ValidateIr                       :: 81;
    VerbosePaths                     :: 82;
    VerifyDebugSerialIr              :: 83;
    NoCodeGen                        :: 84;

    FileSystem                       :: 85;
    Heterogeneous                    :: 86;
    NoMangle                         :: 87;
    NoHLSLBinding                    :: 88;
    NoHLSLPackConstantBufferElements :: 89;
    ValidateUniformity               :: 90;
    AllowGLSL                        :: 91;
    EnableExperimentalPasses         :: 92;

    ArchiveType                      :: 93;
    CompileCoreModule                :: 94;
    Doc                              :: 95;
    IrCompression                    :: 96;
    LoadCoreModule                   :: 97;
    ReferenceModule                  :: 98;
    SaveCoreModule                   :: 99;
    SaveCoreModuleBinSource          :: 100;
    TrackLiveness                    :: 101;
    LoopInversion                    :: 102;

    ParameterBlocksUseRegisterSpaces :: 103;

    CountOfParsableOptions           :: 104;

    DebugInformationFormat           :: 105;
    VulkanBindShiftAll               :: 106;
    GenerateWholeProgram             :: 107;
    UseUpToDateBinaryModule          :: 108;

    EmbedDownstreamIR                :: 109;
    ForceDXLayout                    :: 110;

    EmitSpirvMethod                  :: 111;
    CountOf                          :: 112;
}

CompilerOptionValueKind :: enum s32 {
    Int    :: 0;
    String :: 1;
}

CompilerOptionValue :: struct {
    kind:         CompilerOptionValueKind = .Int;
    intValue0:    s32 = 0;
    intValue1:    s32 = 0;
    stringValue0: *u8 = null;
    stringValue1: *u8 = null;
}

CompilerOptionEntry :: struct {
    name:  CompilerOptionName;
    value: CompilerOptionValue;
}

/*!
@brief A request for one or more compilation actions to be performed.
*/
ICompileRequest :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) icompilerequest_vtable: *ICompileRequest_VTable;
}
ICompileRequest_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    setFileSystem: (this: *ICompileRequest, fileSystem: *ISlangFileSystem) -> void #cpp_method;
    setCompileFlags: (this: *ICompileRequest, flags: SlangCompileFlags) -> void #cpp_method;
    getCompileFlags: (this: *ICompileRequest) -> SlangCompileFlags #cpp_method;
    setDumpIntermediates: (this: *ICompileRequest, enable: s32) -> void #cpp_method;
    setDumpIntermediatePrefix: (this: *ICompileRequest, prefix: *u8) -> void #cpp_method;
    setLineDirectiveMode: (this: *ICompileRequest, mode: SlangLineDirectiveMode) -> void #cpp_method;
    setCodeGenTarget: (this: *ICompileRequest, target: SlangCompileTarget) -> void #cpp_method;
    addCodeGenTarget: (this: *ICompileRequest, target: SlangCompileTarget) -> s32 #cpp_method;
    setTargetProfile: (this: *ICompileRequest, targetIndex: s32, profile: SlangProfileID) -> void #cpp_method;
    setTargetFlags: (this: *ICompileRequest, targetIndex: s32, flags: SlangTargetFlags) -> void #cpp_method;
    setTargetFloatingPointMode: (this: *ICompileRequest, targetIndex: s32, mode: SlangFloatingPointMode) -> void #cpp_method;
    setTargetMatrixLayoutMode: (this: *ICompileRequest, targetIndex: s32, mode: SlangMatrixLayoutMode) -> void #cpp_method;
    setMatrixLayoutMode: (this: *ICompileRequest, mode: SlangMatrixLayoutMode) -> void #cpp_method;
    setDebugInfoLevel: (this: *ICompileRequest, level: SlangDebugInfoLevel) -> void #cpp_method;
    setOptimizationLevel: (this: *ICompileRequest, level: SlangOptimizationLevel) -> void #cpp_method;
    setOutputContainerFormat: (this: *ICompileRequest, format: SlangContainerFormat) -> void #cpp_method;
    setPassThrough: (this: *ICompileRequest, passThrough: SlangPassThrough) -> void #cpp_method;
    setDiagnosticCallback: (this: *ICompileRequest, callback: SlangDiagnosticCallback, userData: *void) -> void #cpp_method;
    setWriter: (this: *ICompileRequest, channel: SlangWriterChannel, writer: *ISlangWriter) -> void #cpp_method;
    getWriter: (this: *ICompileRequest, channel: SlangWriterChannel) -> *ISlangWriter #cpp_method;
    addSearchPath: (this: *ICompileRequest, searchDir: *u8) -> void #cpp_method;
    addPreprocessorDefine: (this: *ICompileRequest, key: *u8, value: *u8) -> void #cpp_method;
    processCommandLineArguments: (this: *ICompileRequest, args: **u8, argCount: s32) -> SlangResult #cpp_method;
    addTranslationUnit: (this: *ICompileRequest, language: SlangSourceLanguage, name: *u8) -> s32 #cpp_method;
    setDefaultModuleName: (this: *ICompileRequest, defaultModuleName: *u8) -> void #cpp_method;
    addTranslationUnitPreprocessorDefine: (this: *ICompileRequest, translationUnitIndex: s32, key: *u8, value: *u8) -> void #cpp_method;
    addTranslationUnitSourceFile: (this: *ICompileRequest, translationUnitIndex: s32, path: *u8) -> void #cpp_method;
    addTranslationUnitSourceString: (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, source: *u8) -> void #cpp_method;
    addLibraryReference: (this: *ICompileRequest, basePath: *u8, libData: *void, libDataSize: u64) -> SlangResult #cpp_method;
    addTranslationUnitSourceStringSpan: (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, sourceBegin: *u8, sourceEnd: *u8) -> void #cpp_method;
    addTranslationUnitSourceBlob: (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, sourceBlob: *ISlangBlob) -> void #cpp_method;
    addEntryPoint: (this: *ICompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage) -> s32 #cpp_method;
    addEntryPointEx: (this: *ICompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage, genericArgCount: s32, genericArgs: **u8) -> s32 #cpp_method;
    setGlobalGenericArgs: (this: *ICompileRequest, genericArgCount: s32, genericArgs: **u8) -> SlangResult #cpp_method;
    setTypeNameForGlobalExistentialTypeParam: (this: *ICompileRequest, slotIndex: s32, typeName: *u8) -> SlangResult #cpp_method;
    setTypeNameForEntryPointExistentialTypeParam: (this: *ICompileRequest, entryPointIndex: s32, slotIndex: s32, typeName: *u8) -> SlangResult #cpp_method;
    setAllowGLSLInput: (this: *ICompileRequest, value: bool) -> void #cpp_method;
    compile: (this: *ICompileRequest) -> SlangResult #cpp_method;
    getDiagnosticOutput: (this: *ICompileRequest) -> *u8 #cpp_method;
    getDiagnosticOutputBlob: (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    getDependencyFileCount: (this: *ICompileRequest) -> s32 #cpp_method;
    getDependencyFilePath: (this: *ICompileRequest, index: s32) -> *u8 #cpp_method;
    getTranslationUnitCount: (this: *ICompileRequest) -> s32 #cpp_method;
    getEntryPointSource: (this: *ICompileRequest, entryPointIndex: s32) -> *u8 #cpp_method;
    getEntryPointCode: (this: *ICompileRequest, entryPointIndex: s32, outSize: *u64) -> *void #cpp_method;
    getEntryPointCodeBlob: (this: *ICompileRequest, entryPointIndex: s32, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    getEntryPointHostCallable: (this: *ICompileRequest, entryPointIndex: s32, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult #cpp_method;
    getTargetCodeBlob: (this: *ICompileRequest, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    getTargetHostCallable: (this: *ICompileRequest, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult #cpp_method;
    getCompileRequestCode: (this: *ICompileRequest, outSize: *u64) -> *void #cpp_method;
    getCompileRequestResultAsFileSystem: (this: *ICompileRequest) -> *ISlangMutableFileSystem #cpp_method;
    getContainerCode: (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    loadRepro: (this: *ICompileRequest, fileSystem: *ISlangFileSystem, data: *void, size: u64) -> SlangResult #cpp_method;
    saveRepro: (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    enableReproCapture: (this: *ICompileRequest) -> SlangResult #cpp_method;
    getProgram: (this: *ICompileRequest, outProgram: **IComponentType) -> SlangResult #cpp_method;
    getEntryPoint: (this: *ICompileRequest, entryPointIndex: SlangInt, outEntryPoint: **IComponentType) -> SlangResult #cpp_method;
    getModule: (this: *ICompileRequest, translationUnitIndex: SlangInt, outModule: **IModule) -> SlangResult #cpp_method;
    getSession: (this: *ICompileRequest, outSession: **ISession) -> SlangResult #cpp_method;
    getReflection: (this: *ICompileRequest) -> *SlangReflection #cpp_method;
    setCommandLineCompilerMode: (this: *ICompileRequest) -> void #cpp_method;
    addTargetCapability: (this: *ICompileRequest, targetIndex: SlangInt, capability: SlangCapabilityID) -> SlangResult #cpp_method;
    getProgramWithEntryPoints: (this: *ICompileRequest, outProgram: **IComponentType) -> SlangResult #cpp_method;
    isParameterLocationUsed: (this: *ICompileRequest, entryPointIndex: SlangInt, targetIndex: SlangInt, category: SlangParameterCategory, spaceIndex: SlangUInt, registerIndex: SlangUInt, outUsed: *bool) -> SlangResult #cpp_method;
    setTargetLineDirectiveMode: (this: *ICompileRequest, targetIndex: SlangInt, mode: SlangLineDirectiveMode) -> void #cpp_method;
    setTargetForceGLSLScalarBufferLayout: (this: *ICompileRequest, targetIndex: s32, forceScalarLayout: bool) -> void #cpp_method;
    overrideDiagnosticSeverity: (this: *ICompileRequest, messageID: SlangInt, overrideSeverity: SlangSeverity) -> void #cpp_method;
    getDiagnosticFlags: (this: *ICompileRequest) -> SlangDiagnosticFlags #cpp_method;
    setDiagnosticFlags: (this: *ICompileRequest, flags: SlangDiagnosticFlags) -> void #cpp_method;
    setDebugInfoFormat: (this: *ICompileRequest, debugFormat: SlangDebugInfoFormat) -> void #cpp_method;
    setEnableEffectAnnotations: (this: *ICompileRequest, value: bool) -> void #cpp_method;
    setReportDownstreamTime: (this: *ICompileRequest, value: bool) -> void #cpp_method;
    setReportPerfBenchmark: (this: *ICompileRequest, value: bool) -> void #cpp_method;
    setSkipSPIRVValidation: (this: *ICompileRequest, value: bool) -> void #cpp_method;
    setTargetUseMinimumSlangOptimization: (this: *ICompileRequest, targetIndex: s32, value: bool) -> void #cpp_method;
    setIgnoreCapabilityCheck: (this: *ICompileRequest, value: bool) -> void #cpp_method;
    getCompileTimeProfile: (this: *ICompileRequest, compileTimeProfile: **ISlangProfiler, shouldClear: bool) -> SlangResult #cpp_method;
    setTargetGenerateWholeProgram: (this: *ICompileRequest, targetIndex: s32, value: bool) -> void #cpp_method;
    setTargetForceDXLayout: (this: *ICompileRequest, targetIndex: s32, value: bool) -> void #cpp_method;
    setTargetEmbedDownstreamIR: (this: *ICompileRequest, targetIndex: s32, value: bool) -> void #cpp_method;
}
ICompileRequest_setFileSystem :: inline (this: *ICompileRequest, fileSystem: *ISlangFileSystem) { this.icompilerequest_vtable.setFileSystem(this, fileSystem); }
ICompileRequest_setCompileFlags :: inline (this: *ICompileRequest, flags: SlangCompileFlags) { this.icompilerequest_vtable.setCompileFlags(this, flags); }
ICompileRequest_getCompileFlags :: inline (this: *ICompileRequest) -> SlangCompileFlags { return this.icompilerequest_vtable.getCompileFlags(this); }
ICompileRequest_setDumpIntermediates :: inline (this: *ICompileRequest, enable: s32) { this.icompilerequest_vtable.setDumpIntermediates(this, enable); }
ICompileRequest_setDumpIntermediatePrefix :: inline (this: *ICompileRequest, prefix: *u8) { this.icompilerequest_vtable.setDumpIntermediatePrefix(this, prefix); }
ICompileRequest_setLineDirectiveMode :: inline (this: *ICompileRequest, mode: SlangLineDirectiveMode) { this.icompilerequest_vtable.setLineDirectiveMode(this, mode); }
ICompileRequest_setCodeGenTarget :: inline (this: *ICompileRequest, target: SlangCompileTarget) { this.icompilerequest_vtable.setCodeGenTarget(this, target); }
ICompileRequest_addCodeGenTarget :: inline (this: *ICompileRequest, target: SlangCompileTarget) -> s32 { return this.icompilerequest_vtable.addCodeGenTarget(this, target); }
ICompileRequest_setTargetProfile :: inline (this: *ICompileRequest, targetIndex: s32, profile: SlangProfileID) { this.icompilerequest_vtable.setTargetProfile(this, targetIndex, profile); }
ICompileRequest_setTargetFlags :: inline (this: *ICompileRequest, targetIndex: s32, flags: SlangTargetFlags) { this.icompilerequest_vtable.setTargetFlags(this, targetIndex, flags); }
ICompileRequest_setTargetFloatingPointMode :: inline (this: *ICompileRequest, targetIndex: s32, mode: SlangFloatingPointMode) { this.icompilerequest_vtable.setTargetFloatingPointMode(this, targetIndex, mode); }
ICompileRequest_setTargetMatrixLayoutMode :: inline (this: *ICompileRequest, targetIndex: s32, mode: SlangMatrixLayoutMode) { this.icompilerequest_vtable.setTargetMatrixLayoutMode(this, targetIndex, mode); }
ICompileRequest_setMatrixLayoutMode :: inline (this: *ICompileRequest, mode: SlangMatrixLayoutMode) { this.icompilerequest_vtable.setMatrixLayoutMode(this, mode); }
ICompileRequest_setDebugInfoLevel :: inline (this: *ICompileRequest, level: SlangDebugInfoLevel) { this.icompilerequest_vtable.setDebugInfoLevel(this, level); }
ICompileRequest_setOptimizationLevel :: inline (this: *ICompileRequest, level: SlangOptimizationLevel) { this.icompilerequest_vtable.setOptimizationLevel(this, level); }
ICompileRequest_setOutputContainerFormat :: inline (this: *ICompileRequest, format: SlangContainerFormat) { this.icompilerequest_vtable.setOutputContainerFormat(this, format); }
ICompileRequest_setPassThrough :: inline (this: *ICompileRequest, passThrough: SlangPassThrough) { this.icompilerequest_vtable.setPassThrough(this, passThrough); }
ICompileRequest_setDiagnosticCallback :: inline (this: *ICompileRequest, callback: SlangDiagnosticCallback, userData: *void) { this.icompilerequest_vtable.setDiagnosticCallback(this, callback, userData); }
ICompileRequest_setWriter :: inline (this: *ICompileRequest, channel: SlangWriterChannel, writer: *ISlangWriter) { this.icompilerequest_vtable.setWriter(this, channel, writer); }
ICompileRequest_getWriter :: inline (this: *ICompileRequest, channel: SlangWriterChannel) -> *ISlangWriter { return this.icompilerequest_vtable.getWriter(this, channel); }
ICompileRequest_addSearchPath :: inline (this: *ICompileRequest, searchDir: *u8) { this.icompilerequest_vtable.addSearchPath(this, searchDir); }
ICompileRequest_addPreprocessorDefine :: inline (this: *ICompileRequest, key: *u8, value: *u8) { this.icompilerequest_vtable.addPreprocessorDefine(this, key, value); }
ICompileRequest_processCommandLineArguments :: inline (this: *ICompileRequest, args: **u8, argCount: s32) -> SlangResult { return this.icompilerequest_vtable.processCommandLineArguments(this, args, argCount); }
ICompileRequest_addTranslationUnit :: inline (this: *ICompileRequest, language: SlangSourceLanguage, name: *u8) -> s32 { return this.icompilerequest_vtable.addTranslationUnit(this, language, name); }
ICompileRequest_setDefaultModuleName :: inline (this: *ICompileRequest, defaultModuleName: *u8) { this.icompilerequest_vtable.setDefaultModuleName(this, defaultModuleName); }
ICompileRequest_addTranslationUnitPreprocessorDefine :: inline (this: *ICompileRequest, translationUnitIndex: s32, key: *u8, value: *u8) { this.icompilerequest_vtable.addTranslationUnitPreprocessorDefine(this, translationUnitIndex, key, value); }
ICompileRequest_addTranslationUnitSourceFile :: inline (this: *ICompileRequest, translationUnitIndex: s32, path: *u8) { this.icompilerequest_vtable.addTranslationUnitSourceFile(this, translationUnitIndex, path); }
ICompileRequest_addTranslationUnitSourceString :: inline (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, source: *u8) { this.icompilerequest_vtable.addTranslationUnitSourceString(this, translationUnitIndex, path, source); }
ICompileRequest_addLibraryReference :: inline (this: *ICompileRequest, basePath: *u8, libData: *void, libDataSize: u64) -> SlangResult { return this.icompilerequest_vtable.addLibraryReference(this, basePath, libData, libDataSize); }
ICompileRequest_addTranslationUnitSourceStringSpan :: inline (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, sourceBegin: *u8, sourceEnd: *u8) { this.icompilerequest_vtable.addTranslationUnitSourceStringSpan(this, translationUnitIndex, path, sourceBegin, sourceEnd); }
ICompileRequest_addTranslationUnitSourceBlob :: inline (this: *ICompileRequest, translationUnitIndex: s32, path: *u8, sourceBlob: *ISlangBlob) { this.icompilerequest_vtable.addTranslationUnitSourceBlob(this, translationUnitIndex, path, sourceBlob); }
ICompileRequest_addEntryPoint :: inline (this: *ICompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage) -> s32 { return this.icompilerequest_vtable.addEntryPoint(this, translationUnitIndex, name, stage); }
ICompileRequest_addEntryPointEx :: inline (this: *ICompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage, genericArgCount: s32, genericArgs: **u8) -> s32 { return this.icompilerequest_vtable.addEntryPointEx(this, translationUnitIndex, name, stage, genericArgCount, genericArgs); }
ICompileRequest_setGlobalGenericArgs :: inline (this: *ICompileRequest, genericArgCount: s32, genericArgs: **u8) -> SlangResult { return this.icompilerequest_vtable.setGlobalGenericArgs(this, genericArgCount, genericArgs); }
ICompileRequest_setTypeNameForGlobalExistentialTypeParam :: inline (this: *ICompileRequest, slotIndex: s32, typeName: *u8) -> SlangResult { return this.icompilerequest_vtable.setTypeNameForGlobalExistentialTypeParam(this, slotIndex, typeName); }
ICompileRequest_setTypeNameForEntryPointExistentialTypeParam :: inline (this: *ICompileRequest, entryPointIndex: s32, slotIndex: s32, typeName: *u8) -> SlangResult { return this.icompilerequest_vtable.setTypeNameForEntryPointExistentialTypeParam(this, entryPointIndex, slotIndex, typeName); }
ICompileRequest_setAllowGLSLInput :: inline (this: *ICompileRequest, value: bool) { this.icompilerequest_vtable.setAllowGLSLInput(this, value); }
ICompileRequest_compile :: inline (this: *ICompileRequest) -> SlangResult { return this.icompilerequest_vtable.compile(this); }
ICompileRequest_getDiagnosticOutput :: inline (this: *ICompileRequest) -> *u8 { return this.icompilerequest_vtable.getDiagnosticOutput(this); }
ICompileRequest_getDiagnosticOutputBlob :: inline (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult { return this.icompilerequest_vtable.getDiagnosticOutputBlob(this, outBlob); }
ICompileRequest_getDependencyFileCount :: inline (this: *ICompileRequest) -> s32 { return this.icompilerequest_vtable.getDependencyFileCount(this); }
ICompileRequest_getDependencyFilePath :: inline (this: *ICompileRequest, index: s32) -> *u8 { return this.icompilerequest_vtable.getDependencyFilePath(this, index); }
ICompileRequest_getTranslationUnitCount :: inline (this: *ICompileRequest) -> s32 { return this.icompilerequest_vtable.getTranslationUnitCount(this); }
ICompileRequest_getEntryPointSource :: inline (this: *ICompileRequest, entryPointIndex: s32) -> *u8 { return this.icompilerequest_vtable.getEntryPointSource(this, entryPointIndex); }
ICompileRequest_getEntryPointCode :: inline (this: *ICompileRequest, entryPointIndex: s32, outSize: *u64) -> *void { return this.icompilerequest_vtable.getEntryPointCode(this, entryPointIndex, outSize); }
ICompileRequest_getEntryPointCodeBlob :: inline (this: *ICompileRequest, entryPointIndex: s32, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult { return this.icompilerequest_vtable.getEntryPointCodeBlob(this, entryPointIndex, targetIndex, outBlob); }
ICompileRequest_getEntryPointHostCallable :: inline (this: *ICompileRequest, entryPointIndex: s32, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult { return this.icompilerequest_vtable.getEntryPointHostCallable(this, entryPointIndex, targetIndex, outSharedLibrary); }
ICompileRequest_getTargetCodeBlob :: inline (this: *ICompileRequest, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult { return this.icompilerequest_vtable.getTargetCodeBlob(this, targetIndex, outBlob); }
ICompileRequest_getTargetHostCallable :: inline (this: *ICompileRequest, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult { return this.icompilerequest_vtable.getTargetHostCallable(this, targetIndex, outSharedLibrary); }
ICompileRequest_getCompileRequestCode :: inline (this: *ICompileRequest, outSize: *u64) -> *void { return this.icompilerequest_vtable.getCompileRequestCode(this, outSize); }
ICompileRequest_getCompileRequestResultAsFileSystem :: inline (this: *ICompileRequest) -> *ISlangMutableFileSystem { return this.icompilerequest_vtable.getCompileRequestResultAsFileSystem(this); }
ICompileRequest_getContainerCode :: inline (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult { return this.icompilerequest_vtable.getContainerCode(this, outBlob); }
ICompileRequest_loadRepro :: inline (this: *ICompileRequest, fileSystem: *ISlangFileSystem, data: *void, size: u64) -> SlangResult { return this.icompilerequest_vtable.loadRepro(this, fileSystem, data, size); }
ICompileRequest_saveRepro :: inline (this: *ICompileRequest, outBlob: **ISlangBlob) -> SlangResult { return this.icompilerequest_vtable.saveRepro(this, outBlob); }
ICompileRequest_enableReproCapture :: inline (this: *ICompileRequest) -> SlangResult { return this.icompilerequest_vtable.enableReproCapture(this); }
ICompileRequest_getProgram :: inline (this: *ICompileRequest, outProgram: **IComponentType) -> SlangResult { return this.icompilerequest_vtable.getProgram(this, outProgram); }
ICompileRequest_getEntryPoint :: inline (this: *ICompileRequest, entryPointIndex: SlangInt, outEntryPoint: **IComponentType) -> SlangResult { return this.icompilerequest_vtable.getEntryPoint(this, entryPointIndex, outEntryPoint); }
ICompileRequest_getModule :: inline (this: *ICompileRequest, translationUnitIndex: SlangInt, outModule: **IModule) -> SlangResult { return this.icompilerequest_vtable.getModule(this, translationUnitIndex, outModule); }
ICompileRequest_getSession :: inline (this: *ICompileRequest, outSession: **ISession) -> SlangResult { return this.icompilerequest_vtable.getSession(this, outSession); }
ICompileRequest_getReflection :: inline (this: *ICompileRequest) -> *SlangReflection { return this.icompilerequest_vtable.getReflection(this); }
ICompileRequest_setCommandLineCompilerMode :: inline (this: *ICompileRequest) { this.icompilerequest_vtable.setCommandLineCompilerMode(this); }
ICompileRequest_addTargetCapability :: inline (this: *ICompileRequest, targetIndex: SlangInt, capability: SlangCapabilityID) -> SlangResult { return this.icompilerequest_vtable.addTargetCapability(this, targetIndex, capability); }
ICompileRequest_getProgramWithEntryPoints :: inline (this: *ICompileRequest, outProgram: **IComponentType) -> SlangResult { return this.icompilerequest_vtable.getProgramWithEntryPoints(this, outProgram); }
ICompileRequest_isParameterLocationUsed :: inline (this: *ICompileRequest, entryPointIndex: SlangInt, targetIndex: SlangInt, category: SlangParameterCategory, spaceIndex: SlangUInt, registerIndex: SlangUInt, outUsed: *bool) -> SlangResult { return this.icompilerequest_vtable.isParameterLocationUsed(this, entryPointIndex, targetIndex, category, spaceIndex, registerIndex, outUsed); }
ICompileRequest_setTargetLineDirectiveMode :: inline (this: *ICompileRequest, targetIndex: SlangInt, mode: SlangLineDirectiveMode) { this.icompilerequest_vtable.setTargetLineDirectiveMode(this, targetIndex, mode); }
ICompileRequest_setTargetForceGLSLScalarBufferLayout :: inline (this: *ICompileRequest, targetIndex: s32, forceScalarLayout: bool) { this.icompilerequest_vtable.setTargetForceGLSLScalarBufferLayout(this, targetIndex, forceScalarLayout); }
ICompileRequest_overrideDiagnosticSeverity :: inline (this: *ICompileRequest, messageID: SlangInt, overrideSeverity: SlangSeverity) { this.icompilerequest_vtable.overrideDiagnosticSeverity(this, messageID, overrideSeverity); }
ICompileRequest_getDiagnosticFlags :: inline (this: *ICompileRequest) -> SlangDiagnosticFlags { return this.icompilerequest_vtable.getDiagnosticFlags(this); }
ICompileRequest_setDiagnosticFlags :: inline (this: *ICompileRequest, flags: SlangDiagnosticFlags) { this.icompilerequest_vtable.setDiagnosticFlags(this, flags); }
ICompileRequest_setDebugInfoFormat :: inline (this: *ICompileRequest, debugFormat: SlangDebugInfoFormat) { this.icompilerequest_vtable.setDebugInfoFormat(this, debugFormat); }
ICompileRequest_setEnableEffectAnnotations :: inline (this: *ICompileRequest, value: bool) { this.icompilerequest_vtable.setEnableEffectAnnotations(this, value); }
ICompileRequest_setReportDownstreamTime :: inline (this: *ICompileRequest, value: bool) { this.icompilerequest_vtable.setReportDownstreamTime(this, value); }
ICompileRequest_setReportPerfBenchmark :: inline (this: *ICompileRequest, value: bool) { this.icompilerequest_vtable.setReportPerfBenchmark(this, value); }
ICompileRequest_setSkipSPIRVValidation :: inline (this: *ICompileRequest, value: bool) { this.icompilerequest_vtable.setSkipSPIRVValidation(this, value); }
ICompileRequest_setTargetUseMinimumSlangOptimization :: inline (this: *ICompileRequest, targetIndex: s32, value: bool) { this.icompilerequest_vtable.setTargetUseMinimumSlangOptimization(this, targetIndex, value); }
ICompileRequest_setIgnoreCapabilityCheck :: inline (this: *ICompileRequest, value: bool) { this.icompilerequest_vtable.setIgnoreCapabilityCheck(this, value); }
ICompileRequest_getCompileTimeProfile :: inline (this: *ICompileRequest, compileTimeProfile: **ISlangProfiler, shouldClear: bool) -> SlangResult { return this.icompilerequest_vtable.getCompileTimeProfile(this, compileTimeProfile, shouldClear); }
ICompileRequest_setTargetGenerateWholeProgram :: inline (this: *ICompileRequest, targetIndex: s32, value: bool) { this.icompilerequest_vtable.setTargetGenerateWholeProgram(this, targetIndex, value); }
ICompileRequest_setTargetForceDXLayout :: inline (this: *ICompileRequest, targetIndex: s32, value: bool) { this.icompilerequest_vtable.setTargetForceDXLayout(this, targetIndex, value); }
ICompileRequest_setTargetEmbedDownstreamIR :: inline (this: *ICompileRequest, targetIndex: s32, value: bool) { this.icompilerequest_vtable.setTargetEmbedDownstreamIR(this, targetIndex, value); }

vtable :: (obj: *ICompileRequest) -> *ICompileRequest_VTable { return obj.icompilerequest_vtable; }


BufferReflection :: struct {}

GenericArgReflection :: union {
    typeVal: *TypeReflection;
    intVal:  s64;
    boolVal: bool;
}

UserAttribute :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

TypeReflection :: struct {
    Kind :: enum s32 {
        None                 :: 0;
        Struct               :: 1;
        Array                :: 2;
        Matrix               :: 3;
        Vector               :: 4;
        Scalar               :: 5;
        ConstantBuffer       :: 6;
        Resource             :: 7;
        SamplerState         :: 8;
        TextureBuffer        :: 9;
        ShaderStorageBuffer  :: 10;
        ParameterBlock       :: 11;
        GenericTypeParameter :: 12;
        Interface            :: 13;
        OutputStream         :: 14;
        Specialized          :: 16;
        Feedback             :: 17;
        Pointer              :: 18;
        DynamicResource      :: 19;
    }

    ScalarType :: enum SlangScalarTypeIntegral {
        None    :: 0;
        Void    :: 1;
        Bool    :: 2;
        Int32   :: 3;
        UInt32  :: 4;
        Int64   :: 5;
        UInt64  :: 6;
        Float16 :: 7;
        Float32 :: 8;
        Float64 :: 9;
        Int8    :: 10;
        UInt8   :: 11;
        Int16   :: 12;
        UInt16  :: 13;
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

ParameterCategory :: enum SlangParameterCategoryIntegral {
    None                       :: 0;
    Mixed                      :: 1;
    ConstantBuffer             :: 2;
    ShaderResource             :: 3;
    UnorderedAccess            :: 4;
    VaryingInput               :: 5;
    VaryingOutput              :: 6;
    SamplerState               :: 7;
    Uniform                    :: 8;
    DescriptorTableSlot        :: 9;
    SpecializationConstant     :: 10;
    PushConstantBuffer         :: 11;
    RegisterSpace              :: 12;
    GenericResource            :: 13;

    RayPayload                 :: 14;
    HitAttributes              :: 15;
    CallablePayload            :: 16;

    ShaderRecord               :: 17;

    ExistentialTypeParam       :: 18;
    ExistentialObjectParam     :: 19;

    SubElementRegisterSpace    :: 20;

    InputAttachmentIndex       :: 21;

    MetalBuffer                :: 2;
    MetalTexture               :: 3;
    MetalArgumentBufferElement :: 22;
    MetalAttribute             :: 23;
    MetalPayload               :: 24;

    VertexInput                :: 5;
    FragmentOutput             :: 6;
}

BindingType :: enum SlangBindingTypeIntegral {
    Unknown                         :: 0;

    Sampler                         :: 1;
    Texture                         :: 2;
    ConstantBuffer                  :: 3;
    ParameterBlock                  :: 4;
    TypedBuffer                     :: 5;
    RawBuffer                       :: 6;
    CombinedTextureSampler          :: 7;
    InputRenderTarget               :: 8;
    InlineUniformData               :: 9;
    RayTracingAccelerationStructure :: 10;
    VaryingInput                    :: 11;
    VaryingOutput                   :: 12;
    ExistentialValue                :: 13;
    PushConstant                    :: 14;

    MutableFlag                     :: 256;

    MutableTexture                  :: 258;
    MutableTypedBuffer              :: 261;
    MutableRawBuffer                :: 262;

    BaseMask                        :: 255;
    ExtMask                         :: 65280;
}

TypeLayoutReflection :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

Modifier :: struct {
    ID :: enum SlangModifierIDIntegral {
        Shared         :: 0;
        NoDiff         :: 1;
        Static         :: 2;
        Const          :: 3;
        Export         :: 4;
        Extern         :: 5;
        Differentiable :: 6;
        Mutating       :: 7;
        In             :: 8;
        Out            :: 9;
        InOut          :: 10;
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

VariableReflection :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

VariableLayoutReflection :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

FunctionReflection :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

GenericReflection :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

EntryPointReflection :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

EntryPointLayout :: EntryPointReflection;

TypeParameterReflection :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

LayoutRules :: enum SlangLayoutRulesIntegral {
    Default                  :: 0;
    MetalArgumentBufferTier2 :: 1;
}

ProgramLayout :: ShaderReflection;
GenericArgType :: SlangReflectionGenericArgType;

ShaderReflection :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

DeclReflection :: struct {
    Kind :: enum s32 {
        Unsupported :: 0;
        Struct      :: 1;
        Func        :: 2;
        Module      :: 3;
        Generic     :: 4;
        Variable    :: 5;
        Namespace   :: 6;
    }

    FilteredList :: struct(K: Kind) {
        count:  u32;
        parent: *DeclReflection;

        FilteredIterator :: struct {
            parent: *DeclReflection;
            count:  u32;
            index:  u32;
        }
    }

    IteratedList :: struct {
        count:  u32;
        parent: *DeclReflection;

        Iterator :: struct {
            parent: *DeclReflection;
            count:  u32;
            index:  u32;
        }
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

CompileCoreModuleFlags :: u32;
CompileCoreModuleFlag :: struct {
    Enum :: enum CompileCoreModuleFlags {
        WriteDocumentation :: 1;
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

IBlob :: ISlangBlob;

/* A global session for interaction with the Slang library.

An application may create and re-use a single global session across
multiple sessions, in order to amortize startups costs (in current
Slang this is mostly the cost of loading the Slang standard library).

The global session is currently *not* thread-safe and objects created from
a single global session should only be used from a single thread at
a time.
*/
IGlobalSession :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) iglobalsession_vtable: *IGlobalSession_VTable;
}
IGlobalSession_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    createSession: (this: *IGlobalSession, desc: *SessionDesc, outSession: **ISession) -> SlangResult #cpp_method;
    findProfile: (this: *IGlobalSession, name: *u8) -> SlangProfileID #cpp_method;
    setDownstreamCompilerPath: (this: *IGlobalSession, passThrough: SlangPassThrough, path: *u8) -> void #cpp_method;
    setDownstreamCompilerPrelude: (this: *IGlobalSession, passThrough: SlangPassThrough, preludeText: *u8) -> void #cpp_method;
    getDownstreamCompilerPrelude: (this: *IGlobalSession, passThrough: SlangPassThrough, outPrelude: **ISlangBlob) -> void #cpp_method;
    getBuildTagString: (this: *IGlobalSession) -> *u8 #cpp_method;
    setDefaultDownstreamCompiler: (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, defaultCompiler: SlangPassThrough) -> SlangResult #cpp_method;
    getDefaultDownstreamCompiler: (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage) -> SlangPassThrough #cpp_method;
    setLanguagePrelude: (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, preludeText: *u8) -> void #cpp_method;
    getLanguagePrelude: (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, outPrelude: **ISlangBlob) -> void #cpp_method;
    createCompileRequest: (this: *IGlobalSession, outCompileRequest: **ICompileRequest) -> SlangResult #cpp_method;
    addBuiltins: (this: *IGlobalSession, sourcePath: *u8, sourceString: *u8) -> void #cpp_method;
    setSharedLibraryLoader: (this: *IGlobalSession, loader: *ISlangSharedLibraryLoader) -> void #cpp_method;
    getSharedLibraryLoader: (this: *IGlobalSession) -> *ISlangSharedLibraryLoader #cpp_method;
    checkCompileTargetSupport: (this: *IGlobalSession, target: SlangCompileTarget) -> SlangResult #cpp_method;
    checkPassThroughSupport: (this: *IGlobalSession, passThrough: SlangPassThrough) -> SlangResult #cpp_method;
    compileCoreModule: (this: *IGlobalSession, flags: CompileCoreModuleFlags) -> SlangResult #cpp_method;
    loadCoreModule: (this: *IGlobalSession, coreModule: *void, coreModuleSizeInBytes: u64) -> SlangResult #cpp_method;
    saveCoreModule: (this: *IGlobalSession, archiveType: SlangArchiveType, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
    findCapability: (this: *IGlobalSession, name: *u8) -> SlangCapabilityID #cpp_method;
    setDownstreamCompilerForTransition: (this: *IGlobalSession, source: SlangCompileTarget, target: SlangCompileTarget, compiler: SlangPassThrough) -> void #cpp_method;
    getDownstreamCompilerForTransition: (this: *IGlobalSession, source: SlangCompileTarget, target: SlangCompileTarget) -> SlangPassThrough #cpp_method;
    getCompilerElapsedTime: (this: *IGlobalSession, outTotalTime: *float64, outDownstreamTime: *float64) -> void #cpp_method;
    setSPIRVCoreGrammar: (this: *IGlobalSession, jsonPath: *u8) -> SlangResult #cpp_method;
    parseCommandLineArguments: (this: *IGlobalSession, argc: s32, argv: **u8, outSessionDesc: *SessionDesc, outAuxAllocation: **ISlangUnknown) -> SlangResult #cpp_method;
    getSessionDescDigest: (this: *IGlobalSession, sessionDesc: *SessionDesc, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
}
IGlobalSession_createSession :: inline (this: *IGlobalSession, desc: *SessionDesc, outSession: **ISession) -> SlangResult { return this.iglobalsession_vtable.createSession(this, desc, outSession); }
IGlobalSession_findProfile :: inline (this: *IGlobalSession, name: *u8) -> SlangProfileID { return this.iglobalsession_vtable.findProfile(this, name); }
IGlobalSession_setDownstreamCompilerPath :: inline (this: *IGlobalSession, passThrough: SlangPassThrough, path: *u8) { this.iglobalsession_vtable.setDownstreamCompilerPath(this, passThrough, path); }
IGlobalSession_setDownstreamCompilerPrelude :: inline (this: *IGlobalSession, passThrough: SlangPassThrough, preludeText: *u8) { this.iglobalsession_vtable.setDownstreamCompilerPrelude(this, passThrough, preludeText); }
IGlobalSession_getDownstreamCompilerPrelude :: inline (this: *IGlobalSession, passThrough: SlangPassThrough, outPrelude: **ISlangBlob) { this.iglobalsession_vtable.getDownstreamCompilerPrelude(this, passThrough, outPrelude); }
IGlobalSession_getBuildTagString :: inline (this: *IGlobalSession) -> *u8 { return this.iglobalsession_vtable.getBuildTagString(this); }
IGlobalSession_setDefaultDownstreamCompiler :: inline (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, defaultCompiler: SlangPassThrough) -> SlangResult { return this.iglobalsession_vtable.setDefaultDownstreamCompiler(this, sourceLanguage, defaultCompiler); }
IGlobalSession_getDefaultDownstreamCompiler :: inline (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage) -> SlangPassThrough { return this.iglobalsession_vtable.getDefaultDownstreamCompiler(this, sourceLanguage); }
IGlobalSession_setLanguagePrelude :: inline (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, preludeText: *u8) { this.iglobalsession_vtable.setLanguagePrelude(this, sourceLanguage, preludeText); }
IGlobalSession_getLanguagePrelude :: inline (this: *IGlobalSession, sourceLanguage: SlangSourceLanguage, outPrelude: **ISlangBlob) { this.iglobalsession_vtable.getLanguagePrelude(this, sourceLanguage, outPrelude); }
IGlobalSession_createCompileRequest :: inline (this: *IGlobalSession, outCompileRequest: **ICompileRequest) -> SlangResult { return this.iglobalsession_vtable.createCompileRequest(this, outCompileRequest); }
IGlobalSession_addBuiltins :: inline (this: *IGlobalSession, sourcePath: *u8, sourceString: *u8) { this.iglobalsession_vtable.addBuiltins(this, sourcePath, sourceString); }
IGlobalSession_setSharedLibraryLoader :: inline (this: *IGlobalSession, loader: *ISlangSharedLibraryLoader) { this.iglobalsession_vtable.setSharedLibraryLoader(this, loader); }
IGlobalSession_getSharedLibraryLoader :: inline (this: *IGlobalSession) -> *ISlangSharedLibraryLoader { return this.iglobalsession_vtable.getSharedLibraryLoader(this); }
IGlobalSession_checkCompileTargetSupport :: inline (this: *IGlobalSession, target: SlangCompileTarget) -> SlangResult { return this.iglobalsession_vtable.checkCompileTargetSupport(this, target); }
IGlobalSession_checkPassThroughSupport :: inline (this: *IGlobalSession, passThrough: SlangPassThrough) -> SlangResult { return this.iglobalsession_vtable.checkPassThroughSupport(this, passThrough); }
IGlobalSession_compileCoreModule :: inline (this: *IGlobalSession, flags: CompileCoreModuleFlags) -> SlangResult { return this.iglobalsession_vtable.compileCoreModule(this, flags); }
IGlobalSession_loadCoreModule :: inline (this: *IGlobalSession, coreModule: *void, coreModuleSizeInBytes: u64) -> SlangResult { return this.iglobalsession_vtable.loadCoreModule(this, coreModule, coreModuleSizeInBytes); }
IGlobalSession_saveCoreModule :: inline (this: *IGlobalSession, archiveType: SlangArchiveType, outBlob: **ISlangBlob) -> SlangResult { return this.iglobalsession_vtable.saveCoreModule(this, archiveType, outBlob); }
IGlobalSession_findCapability :: inline (this: *IGlobalSession, name: *u8) -> SlangCapabilityID { return this.iglobalsession_vtable.findCapability(this, name); }
IGlobalSession_setDownstreamCompilerForTransition :: inline (this: *IGlobalSession, source: SlangCompileTarget, target: SlangCompileTarget, compiler: SlangPassThrough) { this.iglobalsession_vtable.setDownstreamCompilerForTransition(this, source, target, compiler); }
IGlobalSession_getDownstreamCompilerForTransition :: inline (this: *IGlobalSession, source: SlangCompileTarget, target: SlangCompileTarget) -> SlangPassThrough { return this.iglobalsession_vtable.getDownstreamCompilerForTransition(this, source, target); }
IGlobalSession_getCompilerElapsedTime :: inline (this: *IGlobalSession, outTotalTime: *float64, outDownstreamTime: *float64) { this.iglobalsession_vtable.getCompilerElapsedTime(this, outTotalTime, outDownstreamTime); }
IGlobalSession_setSPIRVCoreGrammar :: inline (this: *IGlobalSession, jsonPath: *u8) -> SlangResult { return this.iglobalsession_vtable.setSPIRVCoreGrammar(this, jsonPath); }
IGlobalSession_parseCommandLineArguments :: inline (this: *IGlobalSession, argc: s32, argv: **u8, outSessionDesc: *SessionDesc, outAuxAllocation: **ISlangUnknown) -> SlangResult { return this.iglobalsession_vtable.parseCommandLineArguments(this, argc, argv, outSessionDesc, outAuxAllocation); }
IGlobalSession_getSessionDescDigest :: inline (this: *IGlobalSession, sessionDesc: *SessionDesc, outBlob: **ISlangBlob) -> SlangResult { return this.iglobalsession_vtable.getSessionDescDigest(this, sessionDesc, outBlob); }

vtable :: (obj: *IGlobalSession) -> *IGlobalSession_VTable { return obj.iglobalsession_vtable; }


/* Description of a code generation target.
*/
TargetDesc :: struct {
    /* The size of this structure, in bytes.
    */
    structureSize:               u64 = 48;

    /* The target format to generate code for (e.g., SPIR-V, DXIL, etc.)
    */
    format:                      SlangCompileTarget = .TARGET_UNKNOWN;

    /* The compilation profile supported by the target (e.g., "Shader Model 5.1")
    */
    profile:                     SlangProfileID = .SLANG_PROFILE_UNKNOWN;

    /* Flags for the code generation target. Currently unused. */
    flags:                       SlangTargetFlags = kDefaultTargetFlags;

    /* Default mode to use for floating-point operations on the target.
    */
    floatingPointMode:           SlangFloatingPointMode = .DEFAULT;

    /* The line directive mode for output source code.
    */
    lineDirectiveMode:           SlangLineDirectiveMode = .DEFAULT;

    /* Whether to force `scalar` layout for glsl shader storage buffers.
    */
    forceGLSLScalarBufferLayout  := false;

    /* Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.
    */
    compilerOptionEntries:       *CompilerOptionEntry = null;

    /* Number of additional compiler option entries.
    */
    compilerOptionEntryCount:    u32 = 0;
}

SessionFlags :: u32;
anon_enum :: enum u32 {
    kSessionFlags_None :: 0;
}

PreprocessorMacroDesc :: struct {
    name:  *u8;
    value: *u8;
}

SessionDesc :: struct {
    /* The size of this structure, in bytes.
    */
    structureSize:            u64 = 96;

    /* Code generation targets to include in the session.
    */
    targets:                  *TargetDesc = null;
    targetCount:              SlangInt = 0;

    /* Flags to configure the session.
    */
    flags:                    SessionFlags = xx anon_enum.kSessionFlags_None;

    /* Default layout to assume for variables with matrix types.
    */
    defaultMatrixLayoutMode:  SlangMatrixLayoutMode = .ROW_MAJOR;

    /* Paths to use when searching for `#include`d or `import`ed files.
    */
    searchPaths:              **u8 = null;
    searchPathCount:          SlangInt = 0;

    preprocessorMacros:       *PreprocessorMacroDesc = null;
    preprocessorMacroCount:   SlangInt = 0;

    fileSystem:               *ISlangFileSystem = null;

    enableEffectAnnotations   := false;
    allowGLSLSyntax           := false;

    /* Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.
    */
    compilerOptionEntries:    *CompilerOptionEntry = null;

    /* Number of additional compiler option entries.
    */
    compilerOptionEntryCount: u32 = 0;
}

ContainerType :: enum s32 {
    None             :: 0;
    UnsizedArray     :: 1;
    StructuredBuffer :: 2;
    ConstantBuffer   :: 3;
    ParameterBlock   :: 4;
}

/* A session provides a scope for code that is loaded.

A session can be used to load modules of Slang source code,
and to request target-specific compiled binaries and layout
information.

In order to be able to load code, the session owns a set
of active "search paths" for resolving `#include` directives
and `import` declrations, as well as a set of global
preprocessor definitions that will be used for all code
that gets `import`ed in the session.

If multiple user shaders are loaded in the same session,
and import the same module (e.g., two source files do `import X`)
then there will only be one copy of `X` loaded within the session.

In order to be able to generate target code, the session
owns a list of available compilation targets, which specify
code generation options.

Code loaded and compiled within a session is owned by the session
and will remain resident in memory until the session is released.
Applications wishing to control the memory usage for compiled
and loaded code should use multiple sessions.
*/
ISession :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) isession_vtable: *ISession_VTable;
}
ISession_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    getGlobalSession: (this: *ISession) -> *IGlobalSession #cpp_method;
    loadModule: (this: *ISession, moduleName: *u8, outDiagnostics: **IBlob = null) -> *IModule #cpp_method;
    loadModuleFromSource: (this: *ISession, moduleName: *u8, path: *u8, source: *IBlob, outDiagnostics: **IBlob = null) -> *IModule #cpp_method;
    createCompositeComponentType: (this: *ISession, componentTypes: **IComponentType, componentTypeCount: SlangInt, outCompositeComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult #cpp_method;
    specializeType: (this: *ISession, type: *TypeReflection, specializationArgs: *SpecializationArg, specializationArgCount: SlangInt, outDiagnostics: **ISlangBlob = null) -> *TypeReflection #cpp_method;
    getTypeLayout: (this: *ISession, type: *TypeReflection, targetIndex: SlangInt = 0, rules: LayoutRules = .Default, outDiagnostics: **ISlangBlob = null) -> *TypeLayoutReflection #cpp_method;
    getContainerType: (this: *ISession, elementType: *TypeReflection, containerType: ContainerType, outDiagnostics: **ISlangBlob = null) -> *TypeReflection #cpp_method;
    getDynamicType: (this: *ISession) -> *TypeReflection #cpp_method;
    getTypeRTTIMangledName: (this: *ISession, type: *TypeReflection, outNameBlob: **ISlangBlob) -> SlangResult #cpp_method;
    getTypeConformanceWitnessMangledName: (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outNameBlob: **ISlangBlob) -> SlangResult #cpp_method;
    getTypeConformanceWitnessSequentialID: (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outId: *u32) -> SlangResult #cpp_method;
    createCompileRequest: (this: *ISession, outCompileRequest: **SlangCompileRequest) -> SlangResult #cpp_method;
    createTypeConformanceComponentType: (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outConformance: **ITypeConformance, conformanceIdOverride: SlangInt, outDiagnostics: **ISlangBlob) -> SlangResult #cpp_method;
    loadModuleFromIRBlob: (this: *ISession, moduleName: *u8, path: *u8, source: *IBlob, outDiagnostics: **IBlob = null) -> *IModule #cpp_method;
    getLoadedModuleCount: (this: *ISession) -> SlangInt #cpp_method;
    getLoadedModule: (this: *ISession, index: SlangInt) -> *IModule #cpp_method;
    isBinaryModuleUpToDate: (this: *ISession, modulePath: *u8, binaryModuleBlob: *IBlob) -> bool #cpp_method;
    loadModuleFromSourceString: (this: *ISession, moduleName: *u8, path: *u8, _string: *u8, outDiagnostics: **IBlob = null) -> *IModule #cpp_method;
}
ISession_getGlobalSession :: inline (this: *ISession) -> *IGlobalSession { return this.isession_vtable.getGlobalSession(this); }
ISession_loadModule :: inline (this: *ISession, moduleName: *u8, outDiagnostics: **IBlob = null) -> *IModule { return this.isession_vtable.loadModule(this, moduleName, outDiagnostics); }
ISession_loadModuleFromSource :: inline (this: *ISession, moduleName: *u8, path: *u8, source: *IBlob, outDiagnostics: **IBlob = null) -> *IModule { return this.isession_vtable.loadModuleFromSource(this, moduleName, path, source, outDiagnostics); }
ISession_createCompositeComponentType :: inline (this: *ISession, componentTypes: **IComponentType, componentTypeCount: SlangInt, outCompositeComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult { return this.isession_vtable.createCompositeComponentType(this, componentTypes, componentTypeCount, outCompositeComponentType, outDiagnostics); }
ISession_specializeType :: inline (this: *ISession, type: *TypeReflection, specializationArgs: *SpecializationArg, specializationArgCount: SlangInt, outDiagnostics: **ISlangBlob = null) -> *TypeReflection { return this.isession_vtable.specializeType(this, type, specializationArgs, specializationArgCount, outDiagnostics); }
ISession_getTypeLayout :: inline (this: *ISession, type: *TypeReflection, targetIndex: SlangInt = 0, rules: LayoutRules = .Default, outDiagnostics: **ISlangBlob = null) -> *TypeLayoutReflection { return this.isession_vtable.getTypeLayout(this, type, targetIndex, rules, outDiagnostics); }
ISession_getContainerType :: inline (this: *ISession, elementType: *TypeReflection, containerType: ContainerType, outDiagnostics: **ISlangBlob = null) -> *TypeReflection { return this.isession_vtable.getContainerType(this, elementType, containerType, outDiagnostics); }
ISession_getDynamicType :: inline (this: *ISession) -> *TypeReflection { return this.isession_vtable.getDynamicType(this); }
ISession_getTypeRTTIMangledName :: inline (this: *ISession, type: *TypeReflection, outNameBlob: **ISlangBlob) -> SlangResult { return this.isession_vtable.getTypeRTTIMangledName(this, type, outNameBlob); }
ISession_getTypeConformanceWitnessMangledName :: inline (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outNameBlob: **ISlangBlob) -> SlangResult { return this.isession_vtable.getTypeConformanceWitnessMangledName(this, type, interfaceType, outNameBlob); }
ISession_getTypeConformanceWitnessSequentialID :: inline (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outId: *u32) -> SlangResult { return this.isession_vtable.getTypeConformanceWitnessSequentialID(this, type, interfaceType, outId); }
ISession_createCompileRequest :: inline (this: *ISession, outCompileRequest: **SlangCompileRequest) -> SlangResult { return this.isession_vtable.createCompileRequest(this, outCompileRequest); }
ISession_createTypeConformanceComponentType :: inline (this: *ISession, type: *TypeReflection, interfaceType: *TypeReflection, outConformance: **ITypeConformance, conformanceIdOverride: SlangInt, outDiagnostics: **ISlangBlob) -> SlangResult { return this.isession_vtable.createTypeConformanceComponentType(this, type, interfaceType, outConformance, conformanceIdOverride, outDiagnostics); }
ISession_loadModuleFromIRBlob :: inline (this: *ISession, moduleName: *u8, path: *u8, source: *IBlob, outDiagnostics: **IBlob = null) -> *IModule { return this.isession_vtable.loadModuleFromIRBlob(this, moduleName, path, source, outDiagnostics); }
ISession_getLoadedModuleCount :: inline (this: *ISession) -> SlangInt { return this.isession_vtable.getLoadedModuleCount(this); }
ISession_getLoadedModule :: inline (this: *ISession, index: SlangInt) -> *IModule { return this.isession_vtable.getLoadedModule(this, index); }
ISession_isBinaryModuleUpToDate :: inline (this: *ISession, modulePath: *u8, binaryModuleBlob: *IBlob) -> bool { return this.isession_vtable.isBinaryModuleUpToDate(this, modulePath, binaryModuleBlob); }
ISession_loadModuleFromSourceString :: inline (this: *ISession, moduleName: *u8, path: *u8, _string: *u8, outDiagnostics: **IBlob = null) -> *IModule { return this.isession_vtable.loadModuleFromSourceString(this, moduleName, path, _string, outDiagnostics); }

vtable :: (obj: *ISession) -> *ISession_VTable { return obj.isession_vtable; }


IMetadata :: struct {
    #as using islangcastable: ISlangCastable;
    #overlay (islangcastable) imetadata_vtable: *IMetadata_VTable;
}
IMetadata_VTable :: struct #type_info_none {
    using islangcastable: ISlangCastable_VTable;
    isParameterLocationUsed: (this: *IMetadata, category: SlangParameterCategory, spaceIndex: SlangUInt, registerIndex: SlangUInt, outUsed: *bool) -> SlangResult #cpp_method;
}
IMetadata_isParameterLocationUsed :: inline (this: *IMetadata, category: SlangParameterCategory, spaceIndex: SlangUInt, registerIndex: SlangUInt, outUsed: *bool) -> SlangResult { return this.imetadata_vtable.isParameterLocationUsed(this, category, spaceIndex, registerIndex, outUsed); }

vtable :: (obj: *IMetadata) -> *IMetadata_VTable { return obj.imetadata_vtable; }


/* A component type is a unit of shader code layout, reflection, and linking.

A component type is a unit of shader code that can be included into
a linked and compiled shader program. Each component type may have:

* Zero or more uniform shader parameters, representing textures,
buffers, etc. that the code in the component depends on.

* Zero or more *specialization* parameters, which are type or
value parameters that can be used to synthesize specialized
versions of the component type.

* Zero or more entry points, which are the individually invocable
kernels that can have final code generated.

* Zero or more *requirements*, which are other component
types on which the component type depends.

One example of a component type is a module of Slang code:

* The global-scope shader parameters declared in the module are
the parameters when considered as a component type.

* Any global-scope generic or interface type parameters introduce
specialization parameters for the module.

* A module does not by default include any entry points when
considered as a component type (although the code of the
module might *declare* some entry points).

* Any other modules that are `import`ed in the source code
become requirements of the module, when considered as a
component type.

An entry point is another example of a component type:

* The `uniform` parameters of the entry point function are
its shader parameters when considered as a component type.

* Any generic or interface-type parameters of the entry point
introduce specialization parameters.

* An entry point component type exposes a single entry point (itself).

* An entry point has one requirement for the module in which
it was defined.

Component types can be manipulated in a few ways:

* Multiple component types can be combined into a composite, which
combines all of their code, parameters, etc.

* A component type can be specialized, by "plugging in" types and
values for its specialization parameters.

* A component type can be laid out for a particular target, giving
offsets/bindings to the shader parameters it contains.

* Generated kernel code can be requested for entry points.

*/
IComponentType :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) icomponenttype_vtable: *IComponentType_VTable;
}
IComponentType_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    getSession: (this: *IComponentType) -> *ISession #cpp_method;
    getLayout: (this: *IComponentType, targetIndex: SlangInt = 0, outDiagnostics: **IBlob = null) -> *ProgramLayout #cpp_method;
    getSpecializationParamCount: (this: *IComponentType) -> SlangInt #cpp_method;
    getEntryPointCode: (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    getResultAsFileSystem: (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outFileSystem: **ISlangMutableFileSystem) -> SlangResult #cpp_method;
    getEntryPointHash: (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outHash: **IBlob) -> void #cpp_method;
    specialize: (this: *IComponentType, specializationArgs: *SpecializationArg, specializationArgCount: SlangInt, outSpecializedComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult #cpp_method;
    link: (this: *IComponentType, outLinkedComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult #cpp_method;
    getEntryPointHostCallable: (this: *IComponentType, entryPointIndex: s32, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    renameEntryPoint: (this: *IComponentType, newName: *u8, outEntryPoint: **IComponentType) -> SlangResult #cpp_method;
    linkWithOptions: (this: *IComponentType, outLinkedComponentType: **IComponentType, compilerOptionEntryCount: u32, compilerOptionEntries: *CompilerOptionEntry, outDiagnostics: **ISlangBlob = null) -> SlangResult #cpp_method;
    getTargetCode: (this: *IComponentType, targetIndex: SlangInt, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    getTargetMetadata: (this: *IComponentType, targetIndex: SlangInt, outMetadata: **IMetadata, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    getEntryPointMetadata: (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outMetadata: **IMetadata, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
}
IComponentType_getSession :: inline (this: *IComponentType) -> *ISession { return this.icomponenttype_vtable.getSession(this); }
IComponentType_getLayout :: inline (this: *IComponentType, targetIndex: SlangInt = 0, outDiagnostics: **IBlob = null) -> *ProgramLayout { return this.icomponenttype_vtable.getLayout(this, targetIndex, outDiagnostics); }
IComponentType_getSpecializationParamCount :: inline (this: *IComponentType) -> SlangInt { return this.icomponenttype_vtable.getSpecializationParamCount(this); }
IComponentType_getEntryPointCode :: inline (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult { return this.icomponenttype_vtable.getEntryPointCode(this, entryPointIndex, targetIndex, outCode, outDiagnostics); }
IComponentType_getResultAsFileSystem :: inline (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outFileSystem: **ISlangMutableFileSystem) -> SlangResult { return this.icomponenttype_vtable.getResultAsFileSystem(this, entryPointIndex, targetIndex, outFileSystem); }
IComponentType_getEntryPointHash :: inline (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outHash: **IBlob) { this.icomponenttype_vtable.getEntryPointHash(this, entryPointIndex, targetIndex, outHash); }
IComponentType_specialize :: inline (this: *IComponentType, specializationArgs: *SpecializationArg, specializationArgCount: SlangInt, outSpecializedComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult { return this.icomponenttype_vtable.specialize(this, specializationArgs, specializationArgCount, outSpecializedComponentType, outDiagnostics); }
IComponentType_link :: inline (this: *IComponentType, outLinkedComponentType: **IComponentType, outDiagnostics: **ISlangBlob = null) -> SlangResult { return this.icomponenttype_vtable.link(this, outLinkedComponentType, outDiagnostics); }
IComponentType_getEntryPointHostCallable :: inline (this: *IComponentType, entryPointIndex: s32, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary, outDiagnostics: **IBlob = null) -> SlangResult { return this.icomponenttype_vtable.getEntryPointHostCallable(this, entryPointIndex, targetIndex, outSharedLibrary, outDiagnostics); }
IComponentType_renameEntryPoint :: inline (this: *IComponentType, newName: *u8, outEntryPoint: **IComponentType) -> SlangResult { return this.icomponenttype_vtable.renameEntryPoint(this, newName, outEntryPoint); }
IComponentType_linkWithOptions :: inline (this: *IComponentType, outLinkedComponentType: **IComponentType, compilerOptionEntryCount: u32, compilerOptionEntries: *CompilerOptionEntry, outDiagnostics: **ISlangBlob = null) -> SlangResult { return this.icomponenttype_vtable.linkWithOptions(this, outLinkedComponentType, compilerOptionEntryCount, compilerOptionEntries, outDiagnostics); }
IComponentType_getTargetCode :: inline (this: *IComponentType, targetIndex: SlangInt, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult { return this.icomponenttype_vtable.getTargetCode(this, targetIndex, outCode, outDiagnostics); }
IComponentType_getTargetMetadata :: inline (this: *IComponentType, targetIndex: SlangInt, outMetadata: **IMetadata, outDiagnostics: **IBlob = null) -> SlangResult { return this.icomponenttype_vtable.getTargetMetadata(this, targetIndex, outMetadata, outDiagnostics); }
IComponentType_getEntryPointMetadata :: inline (this: *IComponentType, entryPointIndex: SlangInt, targetIndex: SlangInt, outMetadata: **IMetadata, outDiagnostics: **IBlob = null) -> SlangResult { return this.icomponenttype_vtable.getEntryPointMetadata(this, entryPointIndex, targetIndex, outMetadata, outDiagnostics); }

vtable :: (obj: *IComponentType) -> *IComponentType_VTable { return obj.icomponenttype_vtable; }


IEntryPoint :: struct {
    #as using icomponenttype: IComponentType;
    #overlay (icomponenttype) ientrypoint_vtable: *IEntryPoint_VTable;
}
IEntryPoint_VTable :: struct #type_info_none {
    using icomponenttype: IComponentType_VTable;
    getFunctionReflection: (this: *IEntryPoint) -> *FunctionReflection #cpp_method;
}
IEntryPoint_getFunctionReflection :: inline (this: *IEntryPoint) -> *FunctionReflection { return this.ientrypoint_vtable.getFunctionReflection(this); }

vtable :: (obj: *IEntryPoint) -> *IEntryPoint_VTable { return obj.ientrypoint_vtable; }


ITypeConformance :: struct {
    #as using icomponenttype: IComponentType;
}

/* A module is the granularity of shader code compilation and loading.

In most cases a module corresponds to a single compile "translation unit."
This will often be a single `.slang` or `.hlsl` file and everything it
`#include`s.

Notably, a module `M` does *not* include the things it `import`s, as these
as distinct modules that `M` depends on. There is a directed graph of
module dependencies, and all modules in the graph must belong to the
same session (`ISession`).

A module establishes a namespace for looking up types, functions, etc.
*/
IModule :: struct {
    #as using icomponenttype: IComponentType;
    #overlay (icomponenttype) imodule_vtable: *IModule_VTable;
}
IModule_VTable :: struct #type_info_none {
    using icomponenttype: IComponentType_VTable;
    findEntryPointByName: (this: *IModule, name: *u8, outEntryPoint: **IEntryPoint) -> SlangResult #cpp_method;
    getDefinedEntryPointCount: (this: *IModule) -> SlangInt32 #cpp_method;
    getDefinedEntryPoint: (this: *IModule, index: SlangInt32, outEntryPoint: **IEntryPoint) -> SlangResult #cpp_method;
    serialize: (this: *IModule, outSerializedBlob: **ISlangBlob) -> SlangResult #cpp_method;
    writeToFile: (this: *IModule, fileName: *u8) -> SlangResult #cpp_method;
    getName: (this: *IModule) -> *u8 #cpp_method;
    getFilePath: (this: *IModule) -> *u8 #cpp_method;
    getUniqueIdentity: (this: *IModule) -> *u8 #cpp_method;
    findAndCheckEntryPoint: (this: *IModule, name: *u8, stage: SlangStage, outEntryPoint: **IEntryPoint, outDiagnostics: **ISlangBlob) -> SlangResult #cpp_method;
    getDependencyFileCount: (this: *IModule) -> SlangInt32 #cpp_method;
    getDependencyFilePath: (this: *IModule, index: SlangInt32) -> *u8 #cpp_method;
    getModuleReflection: (this: *IModule) -> *DeclReflection #cpp_method;
}
IModule_findEntryPointByName :: inline (this: *IModule, name: *u8, outEntryPoint: **IEntryPoint) -> SlangResult { return this.imodule_vtable.findEntryPointByName(this, name, outEntryPoint); }
IModule_getDefinedEntryPointCount :: inline (this: *IModule) -> SlangInt32 { return this.imodule_vtable.getDefinedEntryPointCount(this); }
IModule_getDefinedEntryPoint :: inline (this: *IModule, index: SlangInt32, outEntryPoint: **IEntryPoint) -> SlangResult { return this.imodule_vtable.getDefinedEntryPoint(this, index, outEntryPoint); }
IModule_serialize :: inline (this: *IModule, outSerializedBlob: **ISlangBlob) -> SlangResult { return this.imodule_vtable.serialize(this, outSerializedBlob); }
IModule_writeToFile :: inline (this: *IModule, fileName: *u8) -> SlangResult { return this.imodule_vtable.writeToFile(this, fileName); }
IModule_getName :: inline (this: *IModule) -> *u8 { return this.imodule_vtable.getName(this); }
IModule_getFilePath :: inline (this: *IModule) -> *u8 { return this.imodule_vtable.getFilePath(this); }
IModule_getUniqueIdentity :: inline (this: *IModule) -> *u8 { return this.imodule_vtable.getUniqueIdentity(this); }
IModule_findAndCheckEntryPoint :: inline (this: *IModule, name: *u8, stage: SlangStage, outEntryPoint: **IEntryPoint, outDiagnostics: **ISlangBlob) -> SlangResult { return this.imodule_vtable.findAndCheckEntryPoint(this, name, stage, outEntryPoint, outDiagnostics); }
IModule_getDependencyFileCount :: inline (this: *IModule) -> SlangInt32 { return this.imodule_vtable.getDependencyFileCount(this); }
IModule_getDependencyFilePath :: inline (this: *IModule, index: SlangInt32) -> *u8 { return this.imodule_vtable.getDependencyFilePath(this, index); }
IModule_getModuleReflection :: inline (this: *IModule) -> *DeclReflection { return this.imodule_vtable.getModuleReflection(this); }

vtable :: (obj: *IModule) -> *IModule_VTable { return obj.imodule_vtable; }


/* Experimental interface for doing target precompilation of slang modules */
IModulePrecompileService_Experimental :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) imoduleprecompileservice_experimental_vtable: *IModulePrecompileService_Experimental_VTable;
}
IModulePrecompileService_Experimental_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    precompileForTarget: (this: *IModulePrecompileService_Experimental, target: SlangCompileTarget, outDiagnostics: **ISlangBlob) -> SlangResult #cpp_method;
    getPrecompiledTargetCode: (this: *IModulePrecompileService_Experimental, target: SlangCompileTarget, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
    getModuleDependencyCount: (this: *IModulePrecompileService_Experimental) -> SlangInt #cpp_method;
    getModuleDependency: (this: *IModulePrecompileService_Experimental, dependencyIndex: SlangInt, outModule: **IModule, outDiagnostics: **IBlob = null) -> SlangResult #cpp_method;
}
IModulePrecompileService_Experimental_precompileForTarget :: inline (this: *IModulePrecompileService_Experimental, target: SlangCompileTarget, outDiagnostics: **ISlangBlob) -> SlangResult { return this.imoduleprecompileservice_experimental_vtable.precompileForTarget(this, target, outDiagnostics); }
IModulePrecompileService_Experimental_getPrecompiledTargetCode :: inline (this: *IModulePrecompileService_Experimental, target: SlangCompileTarget, outCode: **IBlob, outDiagnostics: **IBlob = null) -> SlangResult { return this.imoduleprecompileservice_experimental_vtable.getPrecompiledTargetCode(this, target, outCode, outDiagnostics); }
IModulePrecompileService_Experimental_getModuleDependencyCount :: inline (this: *IModulePrecompileService_Experimental) -> SlangInt { return this.imoduleprecompileservice_experimental_vtable.getModuleDependencyCount(this); }
IModulePrecompileService_Experimental_getModuleDependency :: inline (this: *IModulePrecompileService_Experimental, dependencyIndex: SlangInt, outModule: **IModule, outDiagnostics: **IBlob = null) -> SlangResult { return this.imoduleprecompileservice_experimental_vtable.getModuleDependency(this, dependencyIndex, outModule, outDiagnostics); }

vtable :: (obj: *IModulePrecompileService_Experimental) -> *IModulePrecompileService_Experimental_VTable { return obj.imoduleprecompileservice_experimental_vtable; }


/* Argument used for specialization to types/values.
*/
SpecializationArg :: struct {
    Kind :: enum s32 {
        Unknown :: 0;
        Type    :: 1;
    }

    /* The kind of specialization argument. */
    kind: Kind;
    union {
        /* A type specialization argument, used for `Kind::Type`. */
        type: *TypeReflection;
    }
}

/* A result code for a Slang API operation.

This type is generally compatible with the Windows API `HRESULT` type. In particular, negative
values indicate failure results, while zero or positive results indicate success.

In general, Slang APIs always return a zero result on success, unless documented otherwise.
Strictly speaking a negative value indicates an error, a positive (or 0) value indicates
success. This can be tested for with the macros SLANG_SUCCEEDED(x) or SLANG_FAILED(x).

It can represent if the call was successful or not. It can also specify in an extensible manner
what facility produced the result (as the integral 'facility') as well as what caused it (as an
integral 'code'). Under the covers SlangResult is represented as a int32_t.

SlangResult is designed to be compatible with COM HRESULT.

It's layout in bits is as follows

Severity | Facility | Code
---------|----------|-----
31       |    30-16 | 15-0

Severity - 1 fail, 0 is success - as SlangResult is signed 32 bits, means negative number
indicates failure. Facility is where the error originated from. Code is the code specific to the
facility.

Result codes have the following styles,
1) SLANG_name
2) SLANG_s_f_name
3) SLANG_s_name

where s is S for success, E for error
f is the short version of the facility name

Style 1 is reserved for SLANG_OK and SLANG_FAIL as they are so commonly used.

It is acceptable to expand 'f' to a longer name to differentiate a name or drop if unique
without it. ie for a facility 'DRIVER' it might make sense to have an error of the form
SLANG_E_DRIVER_OUT_OF_MEMORY
*/
SlangResult :: s32;

/* A "Universally Unique Identifier" (UUID)

The Slang API uses UUIDs to identify interfaces when
using `queryInterface`.

This type is compatible with the `GUID` type defined
by the Component Object Model (COM), but Slang is
not dependent on COM.
*/
SlangUUID :: struct {
    data1: u32;
    data2: u16;
    data3: u16;
    data4: [8] u8;
}

/* Base interface for components exchanged through the API.

This interface definition is compatible with the COM `IUnknown`,
and uses the same UUID, but Slang does not require applications
to use or initialize COM.
*/
ISlangUnknown :: struct {
    vtable: *ISlangUnknown_VTable;
    _GUID :: struct {}
}
ISlangUnknown_VTable :: struct #type_info_none {
    queryInterface: (this: *ISlangUnknown, uuid: *SlangUUID, outObject: **void) -> SlangResult #cpp_method;
    addRef: (this: *ISlangUnknown) -> u32 #cpp_method;
    release: (this: *ISlangUnknown) -> u32 #cpp_method;
}
ISlangUnknown_queryInterface :: inline (this: *ISlangUnknown, uuid: *SlangUUID, outObject: **void) -> SlangResult { return this.vtable.queryInterface(this, uuid, outObject); }
ISlangUnknown_addRef :: inline (this: *ISlangUnknown) -> u32 { return this.vtable.addRef(this); }
ISlangUnknown_release :: inline (this: *ISlangUnknown) -> u32 { return this.vtable.release(this); }

vtable :: (obj: *ISlangUnknown) -> *ISlangUnknown_VTable { return obj.vtable; }


/* An interface to provide a mechanism to cast, that doesn't require ref counting
and doesn't have to return a pointer to a ISlangUnknown derived class */
ISlangCastable :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) islangcastable_vtable: *ISlangCastable_VTable;
}
ISlangCastable_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    castAs: (this: *ISlangCastable, guid: *SlangUUID) -> *void #cpp_method;
}
ISlangCastable_castAs :: inline (this: *ISlangCastable, guid: *SlangUUID) -> *void { return this.islangcastable_vtable.castAs(this, guid); }

vtable :: (obj: *ISlangCastable) -> *ISlangCastable_VTable { return obj.islangcastable_vtable; }


ISlangClonable :: struct {
    #as using islangcastable: ISlangCastable;
    #overlay (islangcastable) islangclonable_vtable: *ISlangClonable_VTable;
}
ISlangClonable_VTable :: struct #type_info_none {
    using islangcastable: ISlangCastable_VTable;
    clone: (this: *ISlangClonable, guid: *SlangUUID) -> *void #cpp_method;
}
ISlangClonable_clone :: inline (this: *ISlangClonable, guid: *SlangUUID) -> *void { return this.islangclonable_vtable.clone(this, guid); }

vtable :: (obj: *ISlangClonable) -> *ISlangClonable_VTable { return obj.islangclonable_vtable; }


/* A "blob" of binary data.

This interface definition is compatible with the `ID3DBlob` and `ID3D10Blob` interfaces.
*/
ISlangBlob :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) islangblob_vtable: *ISlangBlob_VTable;
}
ISlangBlob_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    getBufferPointer: (this: *ISlangBlob) -> *void #cpp_method;
    getBufferSize: (this: *ISlangBlob) -> u64 #cpp_method;
}
ISlangBlob_getBufferPointer :: inline (this: *ISlangBlob) -> *void { return this.islangblob_vtable.getBufferPointer(this); }
ISlangBlob_getBufferSize :: inline (this: *ISlangBlob) -> u64 { return this.islangblob_vtable.getBufferSize(this); }

vtable :: (obj: *ISlangBlob) -> *ISlangBlob_VTable { return obj.islangblob_vtable; }


/* Can be requested from ISlangCastable cast to indicate the contained chars are null
* terminated.
*/
SlangTerminatedChars :: struct {
    chars: [1] u8;
}

/* A (real or virtual) file system.

Slang can make use of this interface whenever it would otherwise try to load files
from disk, allowing applications to hook and/or override filesystem access from
the compiler.

It is the responsibility of
the caller of any method that returns a ISlangBlob to release the blob when it is no
longer used (using 'release').
*/
ISlangFileSystem :: struct {
    #as using islangcastable: ISlangCastable;
    #overlay (islangcastable) islangfilesystem_vtable: *ISlangFileSystem_VTable;
}
ISlangFileSystem_VTable :: struct #type_info_none {
    using islangcastable: ISlangCastable_VTable;
    loadFile: (this: *ISlangFileSystem, path: *u8, outBlob: **ISlangBlob) -> SlangResult #cpp_method;
}
ISlangFileSystem_loadFile :: inline (this: *ISlangFileSystem, path: *u8, outBlob: **ISlangBlob) -> SlangResult { return this.islangfilesystem_vtable.loadFile(this, path, outBlob); }

vtable :: (obj: *ISlangFileSystem) -> *ISlangFileSystem_VTable { return obj.islangfilesystem_vtable; }


SlangFuncPtr :: #type () -> void #c_call;

/*
(DEPRECATED) ISlangSharedLibrary
*/
ISlangSharedLibrary_Dep1 :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) islangsharedlibrary_dep1_vtable: *ISlangSharedLibrary_Dep1_VTable;
}
ISlangSharedLibrary_Dep1_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    findSymbolAddressByName: (this: *ISlangSharedLibrary_Dep1, name: *u8) -> *void #cpp_method;
}
ISlangSharedLibrary_Dep1_findSymbolAddressByName :: inline (this: *ISlangSharedLibrary_Dep1, name: *u8) -> *void { return this.islangsharedlibrary_dep1_vtable.findSymbolAddressByName(this, name); }

vtable :: (obj: *ISlangSharedLibrary_Dep1) -> *ISlangSharedLibrary_Dep1_VTable { return obj.islangsharedlibrary_dep1_vtable; }


/* An interface that can be used to encapsulate access to a shared library. An implementation
does not have to implement the library as a shared library
*/
ISlangSharedLibrary :: struct {
    #as using islangcastable: ISlangCastable;
    #overlay (islangcastable) islangsharedlibrary_vtable: *ISlangSharedLibrary_VTable;
}
ISlangSharedLibrary_VTable :: struct #type_info_none {
    using islangcastable: ISlangCastable_VTable;
    findSymbolAddressByName: (this: *ISlangSharedLibrary, name: *u8) -> *void #cpp_method;
}
ISlangSharedLibrary_findSymbolAddressByName :: inline (this: *ISlangSharedLibrary, name: *u8) -> *void { return this.islangsharedlibrary_vtable.findSymbolAddressByName(this, name); }

vtable :: (obj: *ISlangSharedLibrary) -> *ISlangSharedLibrary_VTable { return obj.islangsharedlibrary_vtable; }


ISlangSharedLibraryLoader :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) islangsharedlibraryloader_vtable: *ISlangSharedLibraryLoader_VTable;
}
ISlangSharedLibraryLoader_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    loadSharedLibrary: (this: *ISlangSharedLibraryLoader, path: *u8, sharedLibraryOut: **ISlangSharedLibrary) -> SlangResult #cpp_method;
}
ISlangSharedLibraryLoader_loadSharedLibrary :: inline (this: *ISlangSharedLibraryLoader, path: *u8, sharedLibraryOut: **ISlangSharedLibrary) -> SlangResult { return this.islangsharedlibraryloader_vtable.loadSharedLibrary(this, path, sharedLibraryOut); }

vtable :: (obj: *ISlangSharedLibraryLoader) -> *ISlangSharedLibraryLoader_VTable { return obj.islangsharedlibraryloader_vtable; }


/* Type that identifies how a path should be interpreted */
SlangPathTypeIntegral :: u32;
SlangPathType :: enum SlangPathTypeIntegral {
    DIRECTORY :: 0;
    FILE      :: 1;

    SLANG_PATH_TYPE_DIRECTORY :: DIRECTORY;
    SLANG_PATH_TYPE_FILE      :: FILE;
}

/* Callback to enumerate the contents of of a directory in a ISlangFileSystemExt.
The name is the name of a file system object (directory/file) in the specified path (ie it is
without a path) */
FileSystemContentsCallBack :: #type (pathType: SlangPathType, name: *u8, userData: *void) -> void #c_call;

/* Determines how paths map to files on the OS file system */
OSPathKind :: enum u8 {
    None            :: 0;
    Direct          :: 1;
    OperatingSystem :: 2;
}

/* Used to determine what kind of path is required from an input path */
PathKind :: enum s32 {
    Simplified      :: 0;

    Canonical       :: 1;

    Display         :: 2;

    OperatingSystem :: 3;

    CountOf         :: 4;
}

/* An extended file system abstraction.

Implementing and using this interface over ISlangFileSystem gives much more control over how
paths are managed, as well as how it is determined if two files 'are the same'.

All paths as input char*, or output as ISlangBlobs are always encoded as UTF-8 strings.
Blobs that contain strings are always zero terminated.
*/
ISlangFileSystemExt :: struct {
    #as using islangfilesystem: ISlangFileSystem;
    #overlay (islangfilesystem) islangfilesystemext_vtable: *ISlangFileSystemExt_VTable;
}
ISlangFileSystemExt_VTable :: struct #type_info_none {
    using islangfilesystem: ISlangFileSystem_VTable;
    getFileUniqueIdentity: (this: *ISlangFileSystemExt, path: *u8, outUniqueIdentity: **ISlangBlob) -> SlangResult #cpp_method;
    calcCombinedPath: (this: *ISlangFileSystemExt, fromPathType: SlangPathType, fromPath: *u8, path: *u8, pathOut: **ISlangBlob) -> SlangResult #cpp_method;
    getPathType: (this: *ISlangFileSystemExt, path: *u8, pathTypeOut: *SlangPathType) -> SlangResult #cpp_method;
    getPath: (this: *ISlangFileSystemExt, kind: PathKind, path: *u8, outPath: **ISlangBlob) -> SlangResult #cpp_method;
    clearCache: (this: *ISlangFileSystemExt) -> void #cpp_method;
    enumeratePathContents: (this: *ISlangFileSystemExt, path: *u8, callback: FileSystemContentsCallBack, userData: *void) -> SlangResult #cpp_method;
    getOSPathKind: (this: *ISlangFileSystemExt) -> OSPathKind #cpp_method;
}
ISlangFileSystemExt_getFileUniqueIdentity :: inline (this: *ISlangFileSystemExt, path: *u8, outUniqueIdentity: **ISlangBlob) -> SlangResult { return this.islangfilesystemext_vtable.getFileUniqueIdentity(this, path, outUniqueIdentity); }
ISlangFileSystemExt_calcCombinedPath :: inline (this: *ISlangFileSystemExt, fromPathType: SlangPathType, fromPath: *u8, path: *u8, pathOut: **ISlangBlob) -> SlangResult { return this.islangfilesystemext_vtable.calcCombinedPath(this, fromPathType, fromPath, path, pathOut); }
ISlangFileSystemExt_getPathType :: inline (this: *ISlangFileSystemExt, path: *u8, pathTypeOut: *SlangPathType) -> SlangResult { return this.islangfilesystemext_vtable.getPathType(this, path, pathTypeOut); }
ISlangFileSystemExt_getPath :: inline (this: *ISlangFileSystemExt, kind: PathKind, path: *u8, outPath: **ISlangBlob) -> SlangResult { return this.islangfilesystemext_vtable.getPath(this, kind, path, outPath); }
ISlangFileSystemExt_clearCache :: inline (this: *ISlangFileSystemExt) { this.islangfilesystemext_vtable.clearCache(this); }
ISlangFileSystemExt_enumeratePathContents :: inline (this: *ISlangFileSystemExt, path: *u8, callback: FileSystemContentsCallBack, userData: *void) -> SlangResult { return this.islangfilesystemext_vtable.enumeratePathContents(this, path, callback, userData); }
ISlangFileSystemExt_getOSPathKind :: inline (this: *ISlangFileSystemExt) -> OSPathKind { return this.islangfilesystemext_vtable.getOSPathKind(this); }

vtable :: (obj: *ISlangFileSystemExt) -> *ISlangFileSystemExt_VTable { return obj.islangfilesystemext_vtable; }


ISlangMutableFileSystem :: struct {
    #as using islangfilesystemext: ISlangFileSystemExt;
    #overlay (islangfilesystemext) islangmutablefilesystem_vtable: *ISlangMutableFileSystem_VTable;
}
ISlangMutableFileSystem_VTable :: struct #type_info_none {
    using islangfilesystemext: ISlangFileSystemExt_VTable;
    saveFile: (this: *ISlangMutableFileSystem, path: *u8, data: *void, size: u64) -> SlangResult #cpp_method;
    saveFileBlob: (this: *ISlangMutableFileSystem, path: *u8, dataBlob: *ISlangBlob) -> SlangResult #cpp_method;
    _remove: (this: *ISlangMutableFileSystem, path: *u8) -> SlangResult #cpp_method;
    createDirectory: (this: *ISlangMutableFileSystem, path: *u8) -> SlangResult #cpp_method;
}
ISlangMutableFileSystem_saveFile :: inline (this: *ISlangMutableFileSystem, path: *u8, data: *void, size: u64) -> SlangResult { return this.islangmutablefilesystem_vtable.saveFile(this, path, data, size); }
ISlangMutableFileSystem_saveFileBlob :: inline (this: *ISlangMutableFileSystem, path: *u8, dataBlob: *ISlangBlob) -> SlangResult { return this.islangmutablefilesystem_vtable.saveFileBlob(this, path, dataBlob); }
ISlangMutableFileSystem__remove :: inline (this: *ISlangMutableFileSystem, path: *u8) -> SlangResult { return this.islangmutablefilesystem_vtable._remove(this, path); }
ISlangMutableFileSystem_createDirectory :: inline (this: *ISlangMutableFileSystem, path: *u8) -> SlangResult { return this.islangmutablefilesystem_vtable.createDirectory(this, path); }

vtable :: (obj: *ISlangMutableFileSystem) -> *ISlangMutableFileSystem_VTable { return obj.islangmutablefilesystem_vtable; }


/* Identifies different types of writer target*/
SlangWriterChannelIntegral :: u32;
SlangWriterChannel :: enum SlangWriterChannelIntegral {
    DIAGNOSTIC :: 0;
    STD_OUTPUT :: 1;
    STD_ERROR  :: 2;
    COUNT_OF   :: 3;

    SLANG_WRITER_CHANNEL_DIAGNOSTIC :: DIAGNOSTIC;
    SLANG_WRITER_CHANNEL_STD_OUTPUT :: STD_OUTPUT;
    SLANG_WRITER_CHANNEL_STD_ERROR  :: STD_ERROR;
    SLANG_WRITER_CHANNEL_COUNT_OF   :: COUNT_OF;
}

SlangWriterModeIntegral :: u32;
SlangWriterMode :: enum SlangWriterModeIntegral {
    TEXT   :: 0;
    BINARY :: 1;

    SLANG_WRITER_MODE_TEXT   :: TEXT;
    SLANG_WRITER_MODE_BINARY :: BINARY;
}

/* A stream typically of text, used for outputting diagnostic as well as other information.
*/
ISlangWriter :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) islangwriter_vtable: *ISlangWriter_VTable;
}
ISlangWriter_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    beginAppendBuffer: (this: *ISlangWriter, maxNumChars: u64) -> *u8 #cpp_method;
    endAppendBuffer: (this: *ISlangWriter, buffer: *u8, numChars: u64) -> SlangResult #cpp_method;
    write: (this: *ISlangWriter, chars: *u8, numChars: u64) -> SlangResult #cpp_method;
    flush: (this: *ISlangWriter) -> void #cpp_method;
    isConsole: (this: *ISlangWriter) -> SlangBool #cpp_method;
    setMode: (this: *ISlangWriter, mode: SlangWriterMode) -> SlangResult #cpp_method;
}
ISlangWriter_beginAppendBuffer :: inline (this: *ISlangWriter, maxNumChars: u64) -> *u8 { return this.islangwriter_vtable.beginAppendBuffer(this, maxNumChars); }
ISlangWriter_endAppendBuffer :: inline (this: *ISlangWriter, buffer: *u8, numChars: u64) -> SlangResult { return this.islangwriter_vtable.endAppendBuffer(this, buffer, numChars); }
ISlangWriter_write :: inline (this: *ISlangWriter, chars: *u8, numChars: u64) -> SlangResult { return this.islangwriter_vtable.write(this, chars, numChars); }
ISlangWriter_flush :: inline (this: *ISlangWriter) { this.islangwriter_vtable.flush(this); }
ISlangWriter_isConsole :: inline (this: *ISlangWriter) -> SlangBool { return this.islangwriter_vtable.isConsole(this); }
ISlangWriter_setMode :: inline (this: *ISlangWriter, mode: SlangWriterMode) -> SlangResult { return this.islangwriter_vtable.setMode(this, mode); }

vtable :: (obj: *ISlangWriter) -> *ISlangWriter_VTable { return obj.islangwriter_vtable; }


ISlangProfiler :: struct {
    #as using islangunknown: ISlangUnknown;
    #overlay (islangunknown) islangprofiler_vtable: *ISlangProfiler_VTable;
}
ISlangProfiler_VTable :: struct #type_info_none {
    using islangunknown: ISlangUnknown_VTable;
    getEntryCount: (this: *ISlangProfiler) -> u64 #cpp_method;
    getEntryName: (this: *ISlangProfiler, index: u32) -> *u8 #cpp_method;
    getEntryTimeMS: (this: *ISlangProfiler, index: u32) -> s64 #cpp_method;
    getEntryInvocationTimes: (this: *ISlangProfiler, index: u32) -> u32 #cpp_method;
}
ISlangProfiler_getEntryCount :: inline (this: *ISlangProfiler) -> u64 { return this.islangprofiler_vtable.getEntryCount(this); }
ISlangProfiler_getEntryName :: inline (this: *ISlangProfiler, index: u32) -> *u8 { return this.islangprofiler_vtable.getEntryName(this, index); }
ISlangProfiler_getEntryTimeMS :: inline (this: *ISlangProfiler, index: u32) -> s64 { return this.islangprofiler_vtable.getEntryTimeMS(this, index); }
ISlangProfiler_getEntryInvocationTimes :: inline (this: *ISlangProfiler, index: u32) -> u32 { return this.islangprofiler_vtable.getEntryInvocationTimes(this, index); }

vtable :: (obj: *ISlangProfiler) -> *ISlangProfiler_VTable { return obj.islangprofiler_vtable; }


/*!
@brief An instance of the Slang library.
*/
SlangSession :: IGlobalSession;

SlangProgramLayout :: struct {}

/*!
@brief A request for one or more compilation actions to be performed.
*/
SlangCompileRequest :: ICompileRequest;

/*!
@brief Callback type used for diagnostic output.
*/
SlangDiagnosticCallback :: #type (message: *u8, userData: *void) -> void #c_call;

/*!
@brief Get the build version 'tag' string. The string is the same as
produced via `git describe --tags --match v*` for the project. If such a
version could not be determined at build time then the contents will be
0.0.0-unknown. Any string can be set by passing
-DSLANG_VERSION_FULL=whatever during the cmake invocation.

This function will return exactly the same result as the method
getBuildTagString on IGlobalSession.

An advantage of using this function over the method is that doing so does
not require the creation of a session, which can be a fairly costly
operation.

@return The build tag string
*/
spGetBuildTagString :: () -> *u8 #foreign libslang;

SlangEntryPoint :: struct {}
SlangEntryPointLayout :: struct {}

SlangReflectionDecl :: struct {}
SlangReflectionModifier :: struct {}
SlangReflectionType :: struct {}
SlangReflectionTypeLayout :: struct {}
SlangReflectionVariable :: struct {}
SlangReflectionVariableLayout :: struct {}
SlangReflectionTypeParameter :: struct {}
SlangReflectionUserAttribute :: struct {}
SlangReflectionFunction :: struct {}
SlangReflectionGeneric :: struct {}

SlangReflectionGenericArg :: union {
    typeVal: *SlangReflectionType;
    intVal:  s64;
    boolVal: bool;
}

SlangReflectionGenericArgType :: enum u32 {
    TYPE :: 0;
    INT  :: 1;
    BOOL :: 2;

    SLANG_GENERIC_ARG_TYPE :: TYPE;
    SLANG_GENERIC_ARG_INT  :: INT;
    SLANG_GENERIC_ARG_BOOL :: BOOL;
}

/*
Type aliases to maintain backward compatibility.
*/
SlangReflection :: SlangProgramLayout;
SlangReflectionEntryPoint :: SlangEntryPointLayout;

// type reflection
SlangTypeKindIntegral :: u32;
SlangTypeKind :: enum SlangTypeKindIntegral {
    NONE                   :: 0;
    STRUCT                 :: 1;
    ARRAY                  :: 2;
    MATRIX                 :: 3;
    VECTOR                 :: 4;
    SCALAR                 :: 5;
    CONSTANT_BUFFER        :: 6;
    RESOURCE               :: 7;
    SAMPLER_STATE          :: 8;
    TEXTURE_BUFFER         :: 9;
    SHADER_STORAGE_BUFFER  :: 10;
    PARAMETER_BLOCK        :: 11;
    GENERIC_TYPE_PARAMETER :: 12;
    INTERFACE              :: 13;
    OUTPUT_STREAM          :: 14;
    MESH_OUTPUT            :: 15;
    SPECIALIZED            :: 16;
    FEEDBACK               :: 17;
    POINTER                :: 18;
    DYNAMIC_RESOURCE       :: 19;
    COUNT                  :: 20;

    SLANG_TYPE_KIND_NONE                   :: NONE;
    SLANG_TYPE_KIND_STRUCT                 :: STRUCT;
    SLANG_TYPE_KIND_ARRAY                  :: ARRAY;
    SLANG_TYPE_KIND_MATRIX                 :: MATRIX;
    SLANG_TYPE_KIND_VECTOR                 :: VECTOR;
    SLANG_TYPE_KIND_SCALAR                 :: SCALAR;
    SLANG_TYPE_KIND_CONSTANT_BUFFER        :: CONSTANT_BUFFER;
    SLANG_TYPE_KIND_RESOURCE               :: RESOURCE;
    SLANG_TYPE_KIND_SAMPLER_STATE          :: SAMPLER_STATE;
    SLANG_TYPE_KIND_TEXTURE_BUFFER         :: TEXTURE_BUFFER;
    SLANG_TYPE_KIND_SHADER_STORAGE_BUFFER  :: SHADER_STORAGE_BUFFER;
    SLANG_TYPE_KIND_PARAMETER_BLOCK        :: PARAMETER_BLOCK;
    SLANG_TYPE_KIND_GENERIC_TYPE_PARAMETER :: GENERIC_TYPE_PARAMETER;
    SLANG_TYPE_KIND_INTERFACE              :: INTERFACE;
    SLANG_TYPE_KIND_OUTPUT_STREAM          :: OUTPUT_STREAM;
    SLANG_TYPE_KIND_MESH_OUTPUT            :: MESH_OUTPUT;
    SLANG_TYPE_KIND_SPECIALIZED            :: SPECIALIZED;
    SLANG_TYPE_KIND_FEEDBACK               :: FEEDBACK;
    SLANG_TYPE_KIND_POINTER                :: POINTER;
    SLANG_TYPE_KIND_DYNAMIC_RESOURCE       :: DYNAMIC_RESOURCE;
    SLANG_TYPE_KIND_COUNT                  :: COUNT;
}

SlangScalarTypeIntegral :: u32;
SlangScalarType :: enum SlangScalarTypeIntegral {
    NONE    :: 0;
    VOID    :: 1;
    BOOL    :: 2;
    INT32   :: 3;
    UINT32  :: 4;
    INT64   :: 5;
    UINT64  :: 6;
    FLOAT16 :: 7;
    FLOAT32 :: 8;
    FLOAT64 :: 9;
    INT8    :: 10;
    UINT8   :: 11;
    INT16   :: 12;
    UINT16  :: 13;
    INTPTR  :: 14;
    UINTPTR :: 15;

    SLANG_SCALAR_TYPE_NONE    :: NONE;
    SLANG_SCALAR_TYPE_VOID    :: VOID;
    SLANG_SCALAR_TYPE_BOOL    :: BOOL;
    SLANG_SCALAR_TYPE_INT32   :: INT32;
    SLANG_SCALAR_TYPE_UINT32  :: UINT32;
    SLANG_SCALAR_TYPE_INT64   :: INT64;
    SLANG_SCALAR_TYPE_UINT64  :: UINT64;
    SLANG_SCALAR_TYPE_FLOAT16 :: FLOAT16;
    SLANG_SCALAR_TYPE_FLOAT32 :: FLOAT32;
    SLANG_SCALAR_TYPE_FLOAT64 :: FLOAT64;
    SLANG_SCALAR_TYPE_INT8    :: INT8;
    SLANG_SCALAR_TYPE_UINT8   :: UINT8;
    SLANG_SCALAR_TYPE_INT16   :: INT16;
    SLANG_SCALAR_TYPE_UINT16  :: UINT16;
    SLANG_SCALAR_TYPE_INTPTR  :: INTPTR;
    SLANG_SCALAR_TYPE_UINTPTR :: UINTPTR;
}

// abstract decl reflection
SlangDeclKindIntegral :: u32;
SlangDeclKind :: enum SlangDeclKindIntegral {
    UNSUPPORTED_FOR_REFLECTION :: 0;
    STRUCT                     :: 1;
    FUNC                       :: 2;
    MODULE                     :: 3;
    GENERIC                    :: 4;
    VARIABLE                   :: 5;
    NAMESPACE                  :: 6;

    SLANG_DECL_KIND_UNSUPPORTED_FOR_REFLECTION :: UNSUPPORTED_FOR_REFLECTION;
    SLANG_DECL_KIND_STRUCT                     :: STRUCT;
    SLANG_DECL_KIND_FUNC                       :: FUNC;
    SLANG_DECL_KIND_MODULE                     :: MODULE;
    SLANG_DECL_KIND_GENERIC                    :: GENERIC;
    SLANG_DECL_KIND_VARIABLE                   :: VARIABLE;
    SLANG_DECL_KIND_NAMESPACE                  :: NAMESPACE;
}

SlangResourceShapeIntegral :: u32;
SlangResourceShape :: enum SlangResourceShapeIntegral {
    RESOURCE_BASE_SHAPE_MASK     :: 15;

    RESOURCE_NONE                :: 0;

    TEXTURE_1D                   :: 1;
    TEXTURE_2D                   :: 2;
    TEXTURE_3D                   :: 3;
    TEXTURE_CUBE                 :: 4;
    TEXTURE_BUFFER               :: 5;

    STRUCTURED_BUFFER            :: 6;
    BYTE_ADDRESS_BUFFER          :: 7;
    RESOURCE_UNKNOWN             :: 8;
    ACCELERATION_STRUCTURE       :: 9;
    TEXTURE_SUBPASS              :: 10;

    RESOURCE_EXT_SHAPE_MASK      :: 240;

    TEXTURE_FEEDBACK_FLAG        :: 16;
    TEXTURE_SHADOW_FLAG          :: 32;
    TEXTURE_ARRAY_FLAG           :: 64;
    TEXTURE_MULTISAMPLE_FLAG     :: 128;

    TEXTURE_1D_ARRAY             :: 65;
    TEXTURE_2D_ARRAY             :: 66;
    TEXTURE_CUBE_ARRAY           :: 68;

    TEXTURE_2D_MULTISAMPLE       :: 130;
    TEXTURE_2D_MULTISAMPLE_ARRAY :: 194;

    TEXTURE_SUBPASS_MULTISAMPLE  :: 138;

    SLANG_RESOURCE_BASE_SHAPE_MASK     :: RESOURCE_BASE_SHAPE_MASK;

    SLANG_RESOURCE_NONE                :: RESOURCE_NONE;

    SLANG_TEXTURE_1D                   :: TEXTURE_1D;
    SLANG_TEXTURE_2D                   :: TEXTURE_2D;
    SLANG_TEXTURE_3D                   :: TEXTURE_3D;
    SLANG_TEXTURE_CUBE                 :: TEXTURE_CUBE;
    SLANG_TEXTURE_BUFFER               :: TEXTURE_BUFFER;

    SLANG_STRUCTURED_BUFFER            :: STRUCTURED_BUFFER;
    SLANG_BYTE_ADDRESS_BUFFER          :: BYTE_ADDRESS_BUFFER;
    SLANG_RESOURCE_UNKNOWN             :: RESOURCE_UNKNOWN;
    SLANG_ACCELERATION_STRUCTURE       :: ACCELERATION_STRUCTURE;
    SLANG_TEXTURE_SUBPASS              :: TEXTURE_SUBPASS;

    SLANG_RESOURCE_EXT_SHAPE_MASK      :: RESOURCE_EXT_SHAPE_MASK;

    SLANG_TEXTURE_FEEDBACK_FLAG        :: TEXTURE_FEEDBACK_FLAG;
    SLANG_TEXTURE_SHADOW_FLAG          :: TEXTURE_SHADOW_FLAG;
    SLANG_TEXTURE_ARRAY_FLAG           :: TEXTURE_ARRAY_FLAG;
    SLANG_TEXTURE_MULTISAMPLE_FLAG     :: TEXTURE_MULTISAMPLE_FLAG;

    SLANG_TEXTURE_1D_ARRAY             :: TEXTURE_1D_ARRAY;
    SLANG_TEXTURE_2D_ARRAY             :: TEXTURE_2D_ARRAY;
    SLANG_TEXTURE_CUBE_ARRAY           :: TEXTURE_CUBE_ARRAY;

    SLANG_TEXTURE_2D_MULTISAMPLE       :: TEXTURE_2D_MULTISAMPLE;
    SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY :: TEXTURE_2D_MULTISAMPLE_ARRAY;

    SLANG_TEXTURE_SUBPASS_MULTISAMPLE  :: TEXTURE_SUBPASS_MULTISAMPLE;
}

SlangResourceAccessIntegral :: u32;
SlangResourceAccess :: enum SlangResourceAccessIntegral {
    NONE           :: 0;
    READ           :: 1;
    READ_WRITE     :: 2;
    RASTER_ORDERED :: 3;
    APPEND         :: 4;
    CONSUME        :: 5;
    WRITE          :: 6;
    FEEDBACK       :: 7;
    UNKNOWN        :: 2147483647;

    SLANG_RESOURCE_ACCESS_NONE           :: NONE;
    SLANG_RESOURCE_ACCESS_READ           :: READ;
    SLANG_RESOURCE_ACCESS_READ_WRITE     :: READ_WRITE;
    SLANG_RESOURCE_ACCESS_RASTER_ORDERED :: RASTER_ORDERED;
    SLANG_RESOURCE_ACCESS_APPEND         :: APPEND;
    SLANG_RESOURCE_ACCESS_CONSUME        :: CONSUME;
    SLANG_RESOURCE_ACCESS_WRITE          :: WRITE;
    SLANG_RESOURCE_ACCESS_FEEDBACK       :: FEEDBACK;
    SLANG_RESOURCE_ACCESS_UNKNOWN        :: UNKNOWN;
}

SlangParameterCategoryIntegral :: u32;
SlangParameterCategory :: enum SlangParameterCategoryIntegral {
    NONE                          :: 0;
    MIXED                         :: 1;
    CONSTANT_BUFFER               :: 2;
    SHADER_RESOURCE               :: 3;
    UNORDERED_ACCESS              :: 4;
    VARYING_INPUT                 :: 5;
    VARYING_OUTPUT                :: 6;
    SAMPLER_STATE                 :: 7;
    UNIFORM                       :: 8;
    DESCRIPTOR_TABLE_SLOT         :: 9;
    SPECIALIZATION_CONSTANT       :: 10;
    PUSH_CONSTANT_BUFFER          :: 11;

    REGISTER_SPACE                :: 12;

    GENERIC                       :: 13;

    RAY_PAYLOAD                   :: 14;
    HIT_ATTRIBUTES                :: 15;
    CALLABLE_PAYLOAD              :: 16;
    SHADER_RECORD                 :: 17;

    EXISTENTIAL_TYPE_PARAM        :: 18;

    EXISTENTIAL_OBJECT_PARAM      :: 19;

    SUB_ELEMENT_REGISTER_SPACE    :: 20;

    SUBPASS                       :: 21;

    METAL_ARGUMENT_BUFFER_ELEMENT :: 22;

    METAL_ATTRIBUTE               :: 23;

    METAL_PAYLOAD                 :: 24;

    COUNT                         :: 25;

    METAL_BUFFER                  :: 2;
    METAL_TEXTURE                 :: 3;
    METAL_SAMPLER                 :: 7;

    VERTEX_INPUT                  :: 5;
    FRAGMENT_OUTPUT               :: 6;
    COUNT_V1                      :: 21;

    SLANG_PARAMETER_CATEGORY_NONE                          :: NONE;
    SLANG_PARAMETER_CATEGORY_MIXED                         :: MIXED;
    SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER               :: CONSTANT_BUFFER;
    SLANG_PARAMETER_CATEGORY_SHADER_RESOURCE               :: SHADER_RESOURCE;
    SLANG_PARAMETER_CATEGORY_UNORDERED_ACCESS              :: UNORDERED_ACCESS;
    SLANG_PARAMETER_CATEGORY_VARYING_INPUT                 :: VARYING_INPUT;
    SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT                :: VARYING_OUTPUT;
    SLANG_PARAMETER_CATEGORY_SAMPLER_STATE                 :: SAMPLER_STATE;
    SLANG_PARAMETER_CATEGORY_UNIFORM                       :: UNIFORM;
    SLANG_PARAMETER_CATEGORY_DESCRIPTOR_TABLE_SLOT         :: DESCRIPTOR_TABLE_SLOT;
    SLANG_PARAMETER_CATEGORY_SPECIALIZATION_CONSTANT       :: SPECIALIZATION_CONSTANT;
    SLANG_PARAMETER_CATEGORY_PUSH_CONSTANT_BUFFER          :: PUSH_CONSTANT_BUFFER;

    SLANG_PARAMETER_CATEGORY_REGISTER_SPACE                :: REGISTER_SPACE;

    SLANG_PARAMETER_CATEGORY_GENERIC                       :: GENERIC;

    SLANG_PARAMETER_CATEGORY_RAY_PAYLOAD                   :: RAY_PAYLOAD;
    SLANG_PARAMETER_CATEGORY_HIT_ATTRIBUTES                :: HIT_ATTRIBUTES;
    SLANG_PARAMETER_CATEGORY_CALLABLE_PAYLOAD              :: CALLABLE_PAYLOAD;
    SLANG_PARAMETER_CATEGORY_SHADER_RECORD                 :: SHADER_RECORD;

    SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM        :: EXISTENTIAL_TYPE_PARAM;

    SLANG_PARAMETER_CATEGORY_EXISTENTIAL_OBJECT_PARAM      :: EXISTENTIAL_OBJECT_PARAM;

    SLANG_PARAMETER_CATEGORY_SUB_ELEMENT_REGISTER_SPACE    :: SUB_ELEMENT_REGISTER_SPACE;

    SLANG_PARAMETER_CATEGORY_SUBPASS                       :: SUBPASS;

    SLANG_PARAMETER_CATEGORY_METAL_ARGUMENT_BUFFER_ELEMENT :: METAL_ARGUMENT_BUFFER_ELEMENT;

    SLANG_PARAMETER_CATEGORY_METAL_ATTRIBUTE               :: METAL_ATTRIBUTE;

    SLANG_PARAMETER_CATEGORY_METAL_PAYLOAD                 :: METAL_PAYLOAD;

    SLANG_PARAMETER_CATEGORY_COUNT                         :: COUNT;

    SLANG_PARAMETER_CATEGORY_METAL_BUFFER                  :: METAL_BUFFER;
    SLANG_PARAMETER_CATEGORY_METAL_TEXTURE                 :: METAL_TEXTURE;
    SLANG_PARAMETER_CATEGORY_METAL_SAMPLER                 :: METAL_SAMPLER;

    SLANG_PARAMETER_CATEGORY_VERTEX_INPUT                  :: VERTEX_INPUT;
    SLANG_PARAMETER_CATEGORY_FRAGMENT_OUTPUT               :: FRAGMENT_OUTPUT;
    SLANG_PARAMETER_CATEGORY_COUNT_V1                      :: COUNT_V1;
}

/* Types of API-managed bindings that a parameter might use.

`SlangBindingType` represents the distinct types of binding ranges that might be
understood by an underlying graphics API or cross-API abstraction layer.
Several of the enumeration cases here correspond to cases of `VkDescriptorType`
defined by the Vulkan API. Note however that the values of this enumeration
are not the same as those of any particular API.

The `SlangBindingType` enumeration is distinct from `SlangParameterCategory`
because `SlangParameterCategory` differentiates the types of parameters for
the purposes of layout, where the layout rules of some targets will treat
parameters of different types as occupying the same binding space for layout
(e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of
`binding` indices, and are not allowed to overlap), while those same types
map to different types of bindingsin the API (e.g., both textures and samplers
use different `VkDescriptorType` values).

When you want to answer "what register/binding did this parameter use?" you
should use `SlangParameterCategory`.

When you wnat to answer "what type of descriptor range should this parameter use?"
you should use `SlangBindingType`.
*/
SlangBindingTypeIntegral :: SlangUInt32;
SlangBindingType :: enum SlangBindingTypeIntegral {
    UNKNOWN                            :: 0;

    SAMPLER                            :: 1;
    TEXTURE                            :: 2;
    CONSTANT_BUFFER                    :: 3;
    PARAMETER_BLOCK                    :: 4;
    TYPED_BUFFER                       :: 5;
    RAW_BUFFER                         :: 6;
    COMBINED_TEXTURE_SAMPLER           :: 7;
    INPUT_RENDER_TARGET                :: 8;
    INLINE_UNIFORM_DATA                :: 9;
    RAY_TRACING_ACCELERATION_STRUCTURE :: 10;

    VARYING_INPUT                      :: 11;
    VARYING_OUTPUT                     :: 12;

    EXISTENTIAL_VALUE                  :: 13;
    PUSH_CONSTANT                      :: 14;

    MUTABLE_FLAG                       :: 256;

    MUTABLE_TETURE                     :: 258;

    MUTABLE_TYPED_BUFFER               :: 261;

    MUTABLE_RAW_BUFFER                 :: 262;

    BASE_MASK                          :: 255;
    EXT_MASK                           :: 65280;

    SLANG_BINDING_TYPE_UNKNOWN                            :: UNKNOWN;

    SLANG_BINDING_TYPE_SAMPLER                            :: SAMPLER;
    SLANG_BINDING_TYPE_TEXTURE                            :: TEXTURE;
    SLANG_BINDING_TYPE_CONSTANT_BUFFER                    :: CONSTANT_BUFFER;
    SLANG_BINDING_TYPE_PARAMETER_BLOCK                    :: PARAMETER_BLOCK;
    SLANG_BINDING_TYPE_TYPED_BUFFER                       :: TYPED_BUFFER;
    SLANG_BINDING_TYPE_RAW_BUFFER                         :: RAW_BUFFER;
    SLANG_BINDING_TYPE_COMBINED_TEXTURE_SAMPLER           :: COMBINED_TEXTURE_SAMPLER;
    SLANG_BINDING_TYPE_INPUT_RENDER_TARGET                :: INPUT_RENDER_TARGET;
    SLANG_BINDING_TYPE_INLINE_UNIFORM_DATA                :: INLINE_UNIFORM_DATA;
    SLANG_BINDING_TYPE_RAY_TRACING_ACCELERATION_STRUCTURE :: RAY_TRACING_ACCELERATION_STRUCTURE;

    SLANG_BINDING_TYPE_VARYING_INPUT                      :: VARYING_INPUT;
    SLANG_BINDING_TYPE_VARYING_OUTPUT                     :: VARYING_OUTPUT;

    SLANG_BINDING_TYPE_EXISTENTIAL_VALUE                  :: EXISTENTIAL_VALUE;
    SLANG_BINDING_TYPE_PUSH_CONSTANT                      :: PUSH_CONSTANT;

    SLANG_BINDING_TYPE_MUTABLE_FLAG                       :: MUTABLE_FLAG;

    SLANG_BINDING_TYPE_MUTABLE_TETURE                     :: MUTABLE_TETURE;

    SLANG_BINDING_TYPE_MUTABLE_TYPED_BUFFER               :: MUTABLE_TYPED_BUFFER;

    SLANG_BINDING_TYPE_MUTABLE_RAW_BUFFER                 :: MUTABLE_RAW_BUFFER;

    SLANG_BINDING_TYPE_BASE_MASK                          :: BASE_MASK;
    SLANG_BINDING_TYPE_EXT_MASK                           :: EXT_MASK;
}

SlangLayoutRulesIntegral :: SlangUInt32;
SlangLayoutRules :: enum SlangLayoutRulesIntegral {
    DEFAULT                      :: 0;
    METAL_ARGUMENT_BUFFER_TIER_2 :: 1;

    SLANG_LAYOUT_RULES_DEFAULT                      :: DEFAULT;
    SLANG_LAYOUT_RULES_METAL_ARGUMENT_BUFFER_TIER_2 :: METAL_ARGUMENT_BUFFER_TIER_2;
}

SlangModifierIDIntegral :: SlangUInt32;
SlangModifierID :: enum SlangModifierIDIntegral {
    SHARED         :: 0;
    NO_DIFF        :: 1;
    STATIC         :: 2;
    CONST          :: 3;
    EXPORT         :: 4;
    EXTERN         :: 5;
    DIFFERENTIABLE :: 6;
    MUTATING       :: 7;
    IN             :: 8;
    OUT            :: 9;
    INOUT          :: 10;

    SLANG_MODIFIER_SHARED         :: SHARED;
    SLANG_MODIFIER_NO_DIFF        :: NO_DIFF;
    SLANG_MODIFIER_STATIC         :: STATIC;
    SLANG_MODIFIER_CONST          :: CONST;
    SLANG_MODIFIER_EXPORT         :: EXPORT;
    SLANG_MODIFIER_EXTERN         :: EXTERN;
    SLANG_MODIFIER_DIFFERENTIABLE :: DIFFERENTIABLE;
    SLANG_MODIFIER_MUTATING       :: MUTATING;
    SLANG_MODIFIER_IN             :: IN;
    SLANG_MODIFIER_OUT            :: OUT;
    SLANG_MODIFIER_INOUT          :: INOUT;
}

SlangImageFormatIntegral :: SlangUInt32;
SlangImageFormat :: enum SlangImageFormatIntegral {
    unknown        :: 0;
    rgba32f        :: 1;
    rgba16f        :: 2;
    rg32f          :: 3;
    rg16f          :: 4;
    r11f_g11f_b10f :: 5;
    r32f           :: 6;
    r16f           :: 7;
    rgba16         :: 8;
    rgb10_a2       :: 9;
    rgba8          :: 10;
    rg16           :: 11;
    rg8            :: 12;
    r16            :: 13;
    r8             :: 14;
    rgba16_snorm   :: 15;
    rgba8_snorm    :: 16;
    rg16_snorm     :: 17;
    rg8_snorm      :: 18;
    r16_snorm      :: 19;
    r8_snorm       :: 20;
    rgba32i        :: 21;
    rgba16i        :: 22;
    rgba8i         :: 23;
    rg32i          :: 24;
    rg16i          :: 25;
    rg8i           :: 26;
    r32i           :: 27;
    r16i           :: 28;
    r8i            :: 29;
    rgba32ui       :: 30;
    rgba16ui       :: 31;
    rgb10_a2ui     :: 32;
    rgba8ui        :: 33;
    rg32ui         :: 34;
    rg16ui         :: 35;
    rg8ui          :: 36;
    r32ui          :: 37;
    r16ui          :: 38;
    r8ui           :: 39;
    r64ui          :: 40;
    r64i           :: 41;

    SLANG_IMAGE_FORMAT_unknown        :: unknown;
    SLANG_IMAGE_FORMAT_rgba32f        :: rgba32f;
    SLANG_IMAGE_FORMAT_rgba16f        :: rgba16f;
    SLANG_IMAGE_FORMAT_rg32f          :: rg32f;
    SLANG_IMAGE_FORMAT_rg16f          :: rg16f;
    SLANG_IMAGE_FORMAT_r11f_g11f_b10f :: r11f_g11f_b10f;
    SLANG_IMAGE_FORMAT_r32f           :: r32f;
    SLANG_IMAGE_FORMAT_r16f           :: r16f;
    SLANG_IMAGE_FORMAT_rgba16         :: rgba16;
    SLANG_IMAGE_FORMAT_rgb10_a2       :: rgb10_a2;
    SLANG_IMAGE_FORMAT_rgba8          :: rgba8;
    SLANG_IMAGE_FORMAT_rg16           :: rg16;
    SLANG_IMAGE_FORMAT_rg8            :: rg8;
    SLANG_IMAGE_FORMAT_r16            :: r16;
    SLANG_IMAGE_FORMAT_r8             :: r8;
    SLANG_IMAGE_FORMAT_rgba16_snorm   :: rgba16_snorm;
    SLANG_IMAGE_FORMAT_rgba8_snorm    :: rgba8_snorm;
    SLANG_IMAGE_FORMAT_rg16_snorm     :: rg16_snorm;
    SLANG_IMAGE_FORMAT_rg8_snorm      :: rg8_snorm;
    SLANG_IMAGE_FORMAT_r16_snorm      :: r16_snorm;
    SLANG_IMAGE_FORMAT_r8_snorm       :: r8_snorm;
    SLANG_IMAGE_FORMAT_rgba32i        :: rgba32i;
    SLANG_IMAGE_FORMAT_rgba16i        :: rgba16i;
    SLANG_IMAGE_FORMAT_rgba8i         :: rgba8i;
    SLANG_IMAGE_FORMAT_rg32i          :: rg32i;
    SLANG_IMAGE_FORMAT_rg16i          :: rg16i;
    SLANG_IMAGE_FORMAT_rg8i           :: rg8i;
    SLANG_IMAGE_FORMAT_r32i           :: r32i;
    SLANG_IMAGE_FORMAT_r16i           :: r16i;
    SLANG_IMAGE_FORMAT_r8i            :: r8i;
    SLANG_IMAGE_FORMAT_rgba32ui       :: rgba32ui;
    SLANG_IMAGE_FORMAT_rgba16ui       :: rgba16ui;
    SLANG_IMAGE_FORMAT_rgb10_a2ui     :: rgb10_a2ui;
    SLANG_IMAGE_FORMAT_rgba8ui        :: rgba8ui;
    SLANG_IMAGE_FORMAT_rg32ui         :: rg32ui;
    SLANG_IMAGE_FORMAT_rg16ui         :: rg16ui;
    SLANG_IMAGE_FORMAT_rg8ui          :: rg8ui;
    SLANG_IMAGE_FORMAT_r32ui          :: r32ui;
    SLANG_IMAGE_FORMAT_r16ui          :: r16ui;
    SLANG_IMAGE_FORMAT_r8ui           :: r8ui;
    SLANG_IMAGE_FORMAT_r64ui          :: r64ui;
    SLANG_IMAGE_FORMAT_r64i           :: r64i;
}

// Shader Parameter Reflection
SlangReflectionParameter :: SlangReflectionVariableLayout;

/*!
@brief Initialize an instance of the Slang library.
*/
spCreateSession :: (deprecated: *u8 = null) -> *SlangSession #foreign libslang;

/*!
@brief Clean up after an instance of the Slang library.
*/
spDestroySession :: (session: *SlangSession) -> void #foreign libslang;

/* @see slang::IGlobalSession::setSharedLibraryLoader
*/
spSessionSetSharedLibraryLoader :: (session: *SlangSession, loader: *ISlangSharedLibraryLoader) -> void #foreign libslang;

/* @see slang::IGlobalSession::getSharedLibraryLoader
*/
spSessionGetSharedLibraryLoader :: (session: *SlangSession) -> *ISlangSharedLibraryLoader #foreign libslang;

/* @see slang::IGlobalSession::checkCompileTargetSupport
*/
spSessionCheckCompileTargetSupport :: (session: *SlangSession, target: SlangCompileTarget) -> SlangResult #foreign libslang;

/* @see slang::IGlobalSession::checkPassThroughSupport
*/
spSessionCheckPassThroughSupport :: (session: *SlangSession, passThrough: SlangPassThrough) -> SlangResult #foreign libslang;

/* @see slang::IGlobalSession::addBuiltins
*/
spAddBuiltins :: (session: *SlangSession, sourcePath: *u8, sourceString: *u8) -> void #foreign libslang;

/* @see slang::IGlobalSession::createCompileRequest
*/
spCreateCompileRequest :: (session: *SlangSession) -> *SlangCompileRequest #foreign libslang;

/*!
@brief Destroy a compile request.
Note a request is a COM object and can be destroyed via 'Release'.
*/
spDestroyCompileRequest :: (request: *SlangCompileRequest) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setFileSystem */
spSetFileSystem :: (request: *SlangCompileRequest, fileSystem: *ISlangFileSystem) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setCompileFlags */
spSetCompileFlags :: (request: *SlangCompileRequest, flags: SlangCompileFlags) -> void #foreign libslang;

/*! @see slang::ICompileRequest::getCompileFlags */
spGetCompileFlags :: (request: *SlangCompileRequest) -> SlangCompileFlags #foreign libslang;

/*! @see slang::ICompileRequest::setDumpIntermediates */
spSetDumpIntermediates :: (request: *SlangCompileRequest, enable: s32) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setDumpIntermediatePrefix */
spSetDumpIntermediatePrefix :: (request: *SlangCompileRequest, prefix: *u8) -> void #foreign libslang;

/*! DEPRECATED: use `spSetTargetLineDirectiveMode` instead.
@see slang::ICompileRequest::setLineDirectiveMode */
spSetLineDirectiveMode :: (request: *SlangCompileRequest, mode: SlangLineDirectiveMode) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setTargetLineDirectiveMode */
spSetTargetLineDirectiveMode :: (request: *SlangCompileRequest, targetIndex: s32, mode: SlangLineDirectiveMode) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setTargetLineDirectiveMode */
spSetTargetForceGLSLScalarBufferLayout :: (request: *SlangCompileRequest, targetIndex: s32, forceScalarLayout: bool) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setTargetUseMinimumSlangOptimization */
spSetTargetUseMinimumSlangOptimization :: (request: *ICompileRequest, targetIndex: s32, val: bool) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setIngoreCapabilityCheck */
spSetIgnoreCapabilityCheck :: (request: *ICompileRequest, val: bool) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setCodeGenTarget */
spSetCodeGenTarget :: (request: *SlangCompileRequest, target: SlangCompileTarget) -> void #foreign libslang;

/*! @see slang::ICompileRequest::addCodeGenTarget */
spAddCodeGenTarget :: (request: *SlangCompileRequest, target: SlangCompileTarget) -> s32 #foreign libslang;

/*! @see slang::ICompileRequest::setTargetProfile */
spSetTargetProfile :: (request: *SlangCompileRequest, targetIndex: s32, profile: SlangProfileID) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setTargetFlags */
spSetTargetFlags :: (request: *SlangCompileRequest, targetIndex: s32, flags: SlangTargetFlags) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setTargetFloatingPointMode */
spSetTargetFloatingPointMode :: (request: *SlangCompileRequest, targetIndex: s32, mode: SlangFloatingPointMode) -> void #foreign libslang;

/*! @see slang::ICompileRequest::addTargetCapability */
spAddTargetCapability :: (request: *ICompileRequest, targetIndex: s32, capability: SlangCapabilityID) -> void #foreign libslang;

/* DEPRECATED: use `spSetMatrixLayoutMode` instead. */
spSetTargetMatrixLayoutMode :: (request: *SlangCompileRequest, targetIndex: s32, mode: SlangMatrixLayoutMode) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setMatrixLayoutMode */
spSetMatrixLayoutMode :: (request: *SlangCompileRequest, mode: SlangMatrixLayoutMode) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setDebugInfoLevel */
spSetDebugInfoLevel :: (request: *SlangCompileRequest, level: SlangDebugInfoLevel) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setDebugInfoFormat */
spSetDebugInfoFormat :: (request: *SlangCompileRequest, format: SlangDebugInfoFormat) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setOptimizationLevel */
spSetOptimizationLevel :: (request: *SlangCompileRequest, level: SlangOptimizationLevel) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setOutputContainerFormat */
spSetOutputContainerFormat :: (request: *SlangCompileRequest, format: SlangContainerFormat) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setPassThrough */
spSetPassThrough :: (request: *SlangCompileRequest, passThrough: SlangPassThrough) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setDiagnosticCallback */
spSetDiagnosticCallback :: (request: *SlangCompileRequest, callback: SlangDiagnosticCallback, userData: *void) -> void #foreign libslang;

/*! @see slang::ICompileRequest::setWriter */
spSetWriter :: (request: *SlangCompileRequest, channel: SlangWriterChannel, writer: *ISlangWriter) -> void #foreign libslang;

/*! @see slang::ICompileRequest::getWriter */
spGetWriter :: (request: *SlangCompileRequest, channel: SlangWriterChannel) -> *ISlangWriter #foreign libslang;

/*! @see slang::ICompileRequest::addSearchPath */
spAddSearchPath :: (request: *SlangCompileRequest, searchDir: *u8) -> void #foreign libslang;

/*! @see slang::ICompileRequest::addPreprocessorDefine */
spAddPreprocessorDefine :: (request: *SlangCompileRequest, key: *u8, value: *u8) -> void #foreign libslang;

/*! @see slang::ICompileRequest::processCommandLineArguments */
spProcessCommandLineArguments :: (request: *SlangCompileRequest, args: **u8, argCount: s32) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::addTranslationUnit */
spAddTranslationUnit :: (request: *SlangCompileRequest, language: SlangSourceLanguage, name: *u8) -> s32 #foreign libslang;

/*! @see slang::ICompileRequest::setDefaultModuleName */
spSetDefaultModuleName :: (request: *SlangCompileRequest, defaultModuleName: *u8) -> void #foreign libslang;

/*! @see slang::ICompileRequest::addPreprocessorDefine */
spTranslationUnit_addPreprocessorDefine :: (request: *SlangCompileRequest, translationUnitIndex: s32, key: *u8, value: *u8) -> void #foreign libslang;

/*! @see slang::ICompileRequest::addTranslationUnitSourceFile */
spAddTranslationUnitSourceFile :: (request: *SlangCompileRequest, translationUnitIndex: s32, path: *u8) -> void #foreign libslang;

/*! @see slang::ICompileRequest::addTranslationUnitSourceString */
spAddTranslationUnitSourceString :: (request: *SlangCompileRequest, translationUnitIndex: s32, path: *u8, source: *u8) -> void #foreign libslang;

/*! @see slang::ICompileRequest::addLibraryReference */
spAddLibraryReference :: (request: *SlangCompileRequest, basePath: *u8, libData: *void, libDataSize: u64) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::addTranslationUnitSourceStringSpan */
spAddTranslationUnitSourceStringSpan :: (request: *SlangCompileRequest, translationUnitIndex: s32, path: *u8, sourceBegin: *u8, sourceEnd: *u8) -> void #foreign libslang;

/*! @see slang::ICompileRequest::addTranslationUnitSourceBlob */
spAddTranslationUnitSourceBlob :: (request: *SlangCompileRequest, translationUnitIndex: s32, path: *u8, sourceBlob: *ISlangBlob) -> void #foreign libslang;

/*! @see slang::IGlobalSession::findProfile */
spFindProfile :: (session: *SlangSession, name: *u8) -> SlangProfileID #foreign libslang;

/*! @see slang::IGlobalSession::findCapability */
spFindCapability :: (session: *SlangSession, name: *u8) -> SlangCapabilityID #foreign libslang;

/*! @see slang::ICompileRequest::addEntryPoint */
spAddEntryPoint :: (request: *SlangCompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage) -> s32 #foreign libslang;

/*! @see slang::ICompileRequest::addEntryPointEx */
spAddEntryPointEx :: (request: *SlangCompileRequest, translationUnitIndex: s32, name: *u8, stage: SlangStage, genericArgCount: s32, genericArgs: **u8) -> s32 #foreign libslang;

/*! @see slang::ICompileRequest::setGlobalGenericArgs */
spSetGlobalGenericArgs :: (request: *SlangCompileRequest, genericArgCount: s32, genericArgs: **u8) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::setTypeNameForGlobalExistentialTypeParam */
spSetTypeNameForGlobalExistentialTypeParam :: (request: *SlangCompileRequest, slotIndex: s32, typeName: *u8) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::setTypeNameForEntryPointExistentialTypeParam */
spSetTypeNameForEntryPointExistentialTypeParam :: (request: *SlangCompileRequest, entryPointIndex: s32, slotIndex: s32, typeName: *u8) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::compile */
spCompile :: (request: *SlangCompileRequest) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::getDiagnosticOutput */
spGetDiagnosticOutput :: (request: *SlangCompileRequest) -> *u8 #foreign libslang;

/*! @see slang::ICompileRequest::getDiagnosticOutputBlob */
spGetDiagnosticOutputBlob :: (request: *SlangCompileRequest, outBlob: **ISlangBlob) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::getDependencyFileCount */
spGetDependencyFileCount :: (request: *SlangCompileRequest) -> s32 #foreign libslang;

/*! @see slang::ICompileRequest::getDependencyFilePath */
spGetDependencyFilePath :: (request: *SlangCompileRequest, index: s32) -> *u8 #foreign libslang;

/*! @see slang::ICompileRequest::getTranslationUnitCount */
spGetTranslationUnitCount :: (request: *SlangCompileRequest) -> s32 #foreign libslang;

/*! @see slang::ICompileRequest::getEntryPointSource */
spGetEntryPointSource :: (request: *SlangCompileRequest, entryPointIndex: s32) -> *u8 #foreign libslang;

/*! @see slang::ICompileRequest::getEntryPointCode */
spGetEntryPointCode :: (request: *SlangCompileRequest, entryPointIndex: s32, outSize: *u64) -> *void #foreign libslang;

/*! @see slang::ICompileRequest::getEntryPointCodeBlob */
spGetEntryPointCodeBlob :: (request: *SlangCompileRequest, entryPointIndex: s32, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::getEntryPointHostCallable */
spGetEntryPointHostCallable :: (request: *SlangCompileRequest, entryPointIndex: s32, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::getTargetCodeBlob */
spGetTargetCodeBlob :: (request: *SlangCompileRequest, targetIndex: s32, outBlob: **ISlangBlob) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::getTargetHostCallable */
spGetTargetHostCallable :: (request: *SlangCompileRequest, targetIndex: s32, outSharedLibrary: **ISlangSharedLibrary) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::getCompileRequestCode */
spGetCompileRequestCode :: (request: *SlangCompileRequest, outSize: *u64) -> *void #foreign libslang;

/*! @see slang::ICompileRequest::getContainerCode */
spGetContainerCode :: (request: *SlangCompileRequest, outBlob: **ISlangBlob) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::loadRepro */
spLoadRepro :: (request: *SlangCompileRequest, fileSystem: *ISlangFileSystem, data: *void, size: u64) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::saveRepro */
spSaveRepro :: (request: *SlangCompileRequest, outBlob: **ISlangBlob) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::enableReproCapture */
spEnableReproCapture :: (request: *SlangCompileRequest) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::getCompileTimeProfile */
spGetCompileTimeProfile :: (request: *SlangCompileRequest, compileTimeProfile: **ISlangProfiler, shouldClear: bool) -> SlangResult #foreign libslang;

/* Extract contents of a repro.

Writes the contained files and manifest with their 'unique' names into fileSystem. For more
details read the docs/repro.md documentation.

@param session          The slang session
@param reproData        Holds the repro data
@param reproDataSize    The size of the repro data
@param fileSystem       File system that the contents of the repro will be written to
@returns                A `SlangResult` to indicate success or failure.
*/
spExtractRepro :: (session: *SlangSession, reproData: *void, reproDataSize: u64, fileSystem: *ISlangMutableFileSystem) -> SlangResult #foreign libslang;

/* Turns a repro into a file system.

Makes the contents of the repro available as a file system - that is able to access the files
with the same paths as were used on the original repro file system.

@param session          The slang session
@param reproData        The repro data
@param reproDataSize    The size of the repro data
@param replaceFileSystem  Will attempt to load by unique names from this file system before
using contents of the repro. Optional.
@param outFileSystem    The file system that can be used to access contents
@returns                A `SlangResult` to indicate success or failure.
*/
spLoadReproAsFileSystem :: (session: *SlangSession, reproData: *void, reproDataSize: u64, replaceFileSystem: *ISlangFileSystem, outFileSystem: **ISlangFileSystemExt) -> SlangResult #foreign libslang;

/*! @see slang::ICompileRequest::overrideDiagnosticSeverity */
spOverrideDiagnosticSeverity :: (request: *SlangCompileRequest, messageID: SlangInt, overrideSeverity: SlangSeverity) -> void #foreign libslang;

/*! @see slang::ICompileRequest::getDiagnosticFlags */
spGetDiagnosticFlags :: (request: *SlangCompileRequest) -> SlangDiagnosticFlags #foreign libslang;

/*! @see slang::ICompileRequest::setDiagnosticFlags */
spSetDiagnosticFlags :: (request: *SlangCompileRequest, flags: SlangDiagnosticFlags) -> void #foreign libslang;

// get reflection data from a compilation request
spGetReflection :: (request: *SlangCompileRequest) -> *SlangReflection #foreign libslang;

// User Attribute
spReflectionUserAttribute_GetName :: (attrib: *SlangReflectionUserAttribute) -> *u8 #foreign libslang;
spReflectionUserAttribute_GetArgumentCount :: (attrib: *SlangReflectionUserAttribute) -> u32 #foreign libslang;

spReflectionUserAttribute_GetArgumentType :: (attrib: *SlangReflectionUserAttribute, index: u32) -> *SlangReflectionType #foreign libslang;

spReflectionUserAttribute_GetArgumentValueInt :: (attrib: *SlangReflectionUserAttribute, index: u32, rs: *s32) -> SlangResult #foreign libslang;

spReflectionUserAttribute_GetArgumentValueFloat :: (attrib: *SlangReflectionUserAttribute, index: u32, rs: *float) -> SlangResult #foreign libslang;

/* Returns the string-typed value of a user attribute argument
The string returned is not null-terminated. The length of the string is returned via
`outSize`. If index of out of range, or if the specified argument is not a string, the
function will return nullptr.
*/
spReflectionUserAttribute_GetArgumentValueString :: (attrib: *SlangReflectionUserAttribute, index: u32, outSize: *u64) -> *u8 #foreign libslang;

// Type Reflection
spReflectionType_GetKind :: (type: *SlangReflectionType) -> SlangTypeKind #foreign libslang;
spReflectionType_GetUserAttributeCount :: (type: *SlangReflectionType) -> u32 #foreign libslang;
spReflectionType_GetUserAttribute :: (type: *SlangReflectionType, index: u32) -> *SlangReflectionUserAttribute #foreign libslang;

spReflectionType_FindUserAttributeByName :: (type: *SlangReflectionType, name: *u8) -> *SlangReflectionUserAttribute #foreign libslang;

spReflectionType_applySpecializations :: (type: *SlangReflectionType, generic: *SlangReflectionGeneric) -> *SlangReflectionType #foreign libslang;

spReflectionType_GetFieldCount :: (type: *SlangReflectionType) -> u32 #foreign libslang;
spReflectionType_GetFieldByIndex :: (type: *SlangReflectionType, index: u32) -> *SlangReflectionVariable #foreign libslang;

/* Returns the number of elements in the given type.

This operation is valid for vector and array types. For other types it returns zero.

When invoked on an unbounded-size array it will return `SLANG_UNBOUNDED_SIZE`,
which is defined to be `~size_t(0)`.

If the size of a type cannot be statically computed, perhaps because it depends on
a generic parameter that has not been bound to a specific value, this function returns zero.
*/
spReflectionType_GetElementCount :: (type: *SlangReflectionType) -> u64 #foreign libslang;

spReflectionType_GetElementType :: (type: *SlangReflectionType) -> *SlangReflectionType #foreign libslang;

spReflectionType_GetRowCount :: (type: *SlangReflectionType) -> u32 #foreign libslang;
spReflectionType_GetColumnCount :: (type: *SlangReflectionType) -> u32 #foreign libslang;
spReflectionType_GetScalarType :: (type: *SlangReflectionType) -> SlangScalarType #foreign libslang;

spReflectionType_GetResourceShape :: (type: *SlangReflectionType) -> SlangResourceShape #foreign libslang;
spReflectionType_GetResourceAccess :: (type: *SlangReflectionType) -> SlangResourceAccess #foreign libslang;
spReflectionType_GetResourceResultType :: (type: *SlangReflectionType) -> *SlangReflectionType #foreign libslang;

spReflectionType_GetName :: (type: *SlangReflectionType) -> *u8 #foreign libslang;

spReflectionType_GetFullName :: (type: *SlangReflectionType, outNameBlob: **ISlangBlob) -> SlangResult #foreign libslang;
spReflectionType_GetGenericContainer :: (type: *SlangReflectionType) -> *SlangReflectionGeneric #foreign libslang;

// Type Layout Reflection
spReflectionTypeLayout_GetType :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionType #foreign libslang;
spReflectionTypeLayout_getKind :: (type: *SlangReflectionTypeLayout) -> SlangTypeKind #foreign libslang;
spReflectionTypeLayout_GetSize :: (type: *SlangReflectionTypeLayout, category: SlangParameterCategory) -> u64 #foreign libslang;

spReflectionTypeLayout_GetStride :: (type: *SlangReflectionTypeLayout, category: SlangParameterCategory) -> u64 #foreign libslang;

spReflectionTypeLayout_getAlignment :: (type: *SlangReflectionTypeLayout, category: SlangParameterCategory) -> s32 #foreign libslang;

spReflectionTypeLayout_GetFieldCount :: (type: *SlangReflectionTypeLayout) -> u32 #foreign libslang;
spReflectionTypeLayout_GetFieldByIndex :: (type: *SlangReflectionTypeLayout, index: u32) -> *SlangReflectionVariableLayout #foreign libslang;

spReflectionTypeLayout_findFieldIndexByName :: (typeLayout: *SlangReflectionTypeLayout, nameBegin: *u8, nameEnd: *u8) -> SlangInt #foreign libslang;

spReflectionTypeLayout_GetExplicitCounter :: (typeLayout: *SlangReflectionTypeLayout) -> *SlangReflectionVariableLayout #foreign libslang;

spReflectionTypeLayout_GetElementStride :: (type: *SlangReflectionTypeLayout, category: SlangParameterCategory) -> u64 #foreign libslang;

spReflectionTypeLayout_GetElementTypeLayout :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionTypeLayout #foreign libslang;

spReflectionTypeLayout_GetElementVarLayout :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionVariableLayout #foreign libslang;

spReflectionTypeLayout_getContainerVarLayout :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionVariableLayout #foreign libslang;

spReflectionTypeLayout_GetParameterCategory :: (type: *SlangReflectionTypeLayout) -> SlangParameterCategory #foreign libslang;

spReflectionTypeLayout_GetCategoryCount :: (type: *SlangReflectionTypeLayout) -> u32 #foreign libslang;

spReflectionTypeLayout_GetCategoryByIndex :: (type: *SlangReflectionTypeLayout, index: u32) -> SlangParameterCategory #foreign libslang;

spReflectionTypeLayout_GetMatrixLayoutMode :: (type: *SlangReflectionTypeLayout) -> SlangMatrixLayoutMode #foreign libslang;

spReflectionTypeLayout_getGenericParamIndex :: (type: *SlangReflectionTypeLayout) -> s32 #foreign libslang;

spReflectionTypeLayout_getPendingDataTypeLayout :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionTypeLayout #foreign libslang;

spReflectionTypeLayout_getSpecializedTypePendingDataVarLayout :: (type: *SlangReflectionTypeLayout) -> *SlangReflectionVariableLayout #foreign libslang;
spReflectionType_getSpecializedTypeArgCount :: (type: *SlangReflectionType) -> SlangInt #foreign libslang;
spReflectionType_getSpecializedTypeArgType :: (type: *SlangReflectionType, index: SlangInt) -> *SlangReflectionType #foreign libslang;

spReflectionTypeLayout_getBindingRangeCount :: (typeLayout: *SlangReflectionTypeLayout) -> SlangInt #foreign libslang;
spReflectionTypeLayout_getBindingRangeType :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangBindingType #foreign libslang;

spReflectionTypeLayout_isBindingRangeSpecializable :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getBindingRangeBindingCount :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getBindingRangeLeafTypeLayout :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> *SlangReflectionTypeLayout #foreign libslang;

spReflectionTypeLayout_getBindingRangeLeafVariable :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> *SlangReflectionVariable #foreign libslang;

spReflectionTypeLayout_getBindingRangeImageFormat :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangImageFormat #foreign libslang;

spReflectionTypeLayout_getFieldBindingRangeOffset :: (typeLayout: *SlangReflectionTypeLayout, fieldIndex: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getExplicitCounterBindingRangeOffset :: (inTypeLayout: *SlangReflectionTypeLayout) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getBindingRangeDescriptorSetIndex :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getBindingRangeFirstDescriptorRangeIndex :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getBindingRangeDescriptorRangeCount :: (typeLayout: *SlangReflectionTypeLayout, index: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getDescriptorSetCount :: (typeLayout: *SlangReflectionTypeLayout) -> SlangInt #foreign libslang;
spReflectionTypeLayout_getDescriptorSetSpaceOffset :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getDescriptorSetDescriptorRangeCount :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getDescriptorSetDescriptorRangeIndexOffset :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt, rangeIndex: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getDescriptorSetDescriptorRangeDescriptorCount :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt, rangeIndex: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getDescriptorSetDescriptorRangeType :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt, rangeIndex: SlangInt) -> SlangBindingType #foreign libslang;

spReflectionTypeLayout_getDescriptorSetDescriptorRangeCategory :: (typeLayout: *SlangReflectionTypeLayout, setIndex: SlangInt, rangeIndex: SlangInt) -> SlangParameterCategory #foreign libslang;

spReflectionTypeLayout_getSubObjectRangeCount :: (typeLayout: *SlangReflectionTypeLayout) -> SlangInt #foreign libslang;
spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex :: (typeLayout: *SlangReflectionTypeLayout, subObjectRangeIndex: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getSubObjectRangeSpaceOffset :: (typeLayout: *SlangReflectionTypeLayout, subObjectRangeIndex: SlangInt) -> SlangInt #foreign libslang;

spReflectionTypeLayout_getSubObjectRangeOffset :: (typeLayout: *SlangReflectionTypeLayout, subObjectRangeIndex: SlangInt) -> *SlangReflectionVariableLayout #foreign libslang;

// Variable Reflection
spReflectionVariable_GetName :: (var: *SlangReflectionVariable) -> *u8 #foreign libslang;
spReflectionVariable_GetType :: (var: *SlangReflectionVariable) -> *SlangReflectionType #foreign libslang;
spReflectionVariable_FindModifier :: (var: *SlangReflectionVariable, modifierID: SlangModifierID) -> *SlangReflectionModifier #foreign libslang;

spReflectionVariable_GetUserAttributeCount :: (var: *SlangReflectionVariable) -> u32 #foreign libslang;
spReflectionVariable_GetUserAttribute :: (var: *SlangReflectionVariable, index: u32) -> *SlangReflectionUserAttribute #foreign libslang;

spReflectionVariable_FindUserAttributeByName :: (var: *SlangReflectionVariable, globalSession: *SlangSession, name: *u8) -> *SlangReflectionUserAttribute #foreign libslang;

spReflectionVariable_HasDefaultValue :: (inVar: *SlangReflectionVariable) -> bool #foreign libslang;
spReflectionVariable_GetGenericContainer :: (var: *SlangReflectionVariable) -> *SlangReflectionGeneric #foreign libslang;

spReflectionVariable_applySpecializations :: (var: *SlangReflectionVariable, generic: *SlangReflectionGeneric) -> *SlangReflectionVariable #foreign libslang;

// Variable Layout Reflection
spReflectionVariableLayout_GetVariable :: (var: *SlangReflectionVariableLayout) -> *SlangReflectionVariable #foreign libslang;

spReflectionVariableLayout_GetTypeLayout :: (var: *SlangReflectionVariableLayout) -> *SlangReflectionTypeLayout #foreign libslang;

spReflectionVariableLayout_GetOffset :: (var: *SlangReflectionVariableLayout, category: SlangParameterCategory) -> u64 #foreign libslang;

spReflectionVariableLayout_GetSpace :: (var: *SlangReflectionVariableLayout, category: SlangParameterCategory) -> u64 #foreign libslang;

spReflectionVariableLayout_GetSemanticName :: (var: *SlangReflectionVariableLayout) -> *u8 #foreign libslang;

spReflectionVariableLayout_GetSemanticIndex :: (var: *SlangReflectionVariableLayout) -> u64 #foreign libslang;

// Function Reflection
spReflectionFunction_asDecl :: (func: *SlangReflectionFunction) -> *SlangReflectionDecl #foreign libslang;
spReflectionFunction_GetName :: (func: *SlangReflectionFunction) -> *u8 #foreign libslang;
spReflectionFunction_FindModifier :: (var: *SlangReflectionFunction, modifierID: SlangModifierID) -> *SlangReflectionModifier #foreign libslang;

spReflectionFunction_GetUserAttributeCount :: (func: *SlangReflectionFunction) -> u32 #foreign libslang;

spReflectionFunction_GetUserAttribute :: (func: *SlangReflectionFunction, index: u32) -> *SlangReflectionUserAttribute #foreign libslang;

spReflectionFunction_FindUserAttributeByName :: (func: *SlangReflectionFunction, globalSession: *SlangSession, name: *u8) -> *SlangReflectionUserAttribute #foreign libslang;

spReflectionFunction_GetParameterCount :: (func: *SlangReflectionFunction) -> u32 #foreign libslang;
spReflectionFunction_GetParameter :: (func: *SlangReflectionFunction, index: u32) -> *SlangReflectionVariable #foreign libslang;

spReflectionFunction_GetResultType :: (func: *SlangReflectionFunction) -> *SlangReflectionType #foreign libslang;

spReflectionFunction_GetGenericContainer :: (func: *SlangReflectionFunction) -> *SlangReflectionGeneric #foreign libslang;

spReflectionFunction_applySpecializations :: (func: *SlangReflectionFunction, generic: *SlangReflectionGeneric) -> *SlangReflectionFunction #foreign libslang;

spReflectionFunction_specializeWithArgTypes :: (func: *SlangReflectionFunction, argTypeCount: SlangInt, argTypes: **SlangReflectionType) -> *SlangReflectionFunction #foreign libslang;

spReflectionFunction_isOverloaded :: (func: *SlangReflectionFunction) -> bool #foreign libslang;
spReflectionFunction_getOverloadCount :: (func: *SlangReflectionFunction) -> u32 #foreign libslang;
spReflectionFunction_getOverload :: (func: *SlangReflectionFunction, index: u32) -> *SlangReflectionFunction #foreign libslang;

// Abstract Decl Reflection
spReflectionDecl_getChildrenCount :: (parentDecl: *SlangReflectionDecl) -> u32 #foreign libslang;
spReflectionDecl_getChild :: (parentDecl: *SlangReflectionDecl, index: u32) -> *SlangReflectionDecl #foreign libslang;

spReflectionDecl_getName :: (decl: *SlangReflectionDecl) -> *u8 #foreign libslang;
spReflectionDecl_getKind :: (decl: *SlangReflectionDecl) -> SlangDeclKind #foreign libslang;
spReflectionDecl_castToFunction :: (decl: *SlangReflectionDecl) -> *SlangReflectionFunction #foreign libslang;
spReflectionDecl_castToVariable :: (decl: *SlangReflectionDecl) -> *SlangReflectionVariable #foreign libslang;
spReflectionDecl_castToGeneric :: (decl: *SlangReflectionDecl) -> *SlangReflectionGeneric #foreign libslang;
spReflection_getTypeFromDecl :: (decl: *SlangReflectionDecl) -> *SlangReflectionType #foreign libslang;
spReflectionDecl_getParent :: (decl: *SlangReflectionDecl) -> *SlangReflectionDecl #foreign libslang;

// Generic Reflection
spReflectionGeneric_asDecl :: (generic: *SlangReflectionGeneric) -> *SlangReflectionDecl #foreign libslang;
spReflectionGeneric_GetName :: (generic: *SlangReflectionGeneric) -> *u8 #foreign libslang;
spReflectionGeneric_GetTypeParameterCount :: (generic: *SlangReflectionGeneric) -> u32 #foreign libslang;

spReflectionGeneric_GetTypeParameter :: (generic: *SlangReflectionGeneric, index: u32) -> *SlangReflectionVariable #foreign libslang;

spReflectionGeneric_GetValueParameterCount :: (generic: *SlangReflectionGeneric) -> u32 #foreign libslang;

spReflectionGeneric_GetValueParameter :: (generic: *SlangReflectionGeneric, index: u32) -> *SlangReflectionVariable #foreign libslang;

spReflectionGeneric_GetTypeParameterConstraintCount :: (generic: *SlangReflectionGeneric, typeParam: *SlangReflectionVariable) -> u32 #foreign libslang;

spReflectionGeneric_GetTypeParameterConstraintType :: (generic: *SlangReflectionGeneric, typeParam: *SlangReflectionVariable, index: u32) -> *SlangReflectionType #foreign libslang;

spReflectionGeneric_GetInnerKind :: (generic: *SlangReflectionGeneric) -> SlangDeclKind #foreign libslang;
spReflectionGeneric_GetInnerDecl :: (generic: *SlangReflectionGeneric) -> *SlangReflectionDecl #foreign libslang;

spReflectionGeneric_GetOuterGenericContainer :: (generic: *SlangReflectionGeneric) -> *SlangReflectionGeneric #foreign libslang;

spReflectionGeneric_GetConcreteType :: (generic: *SlangReflectionGeneric, typeParam: *SlangReflectionVariable) -> *SlangReflectionType #foreign libslang;

spReflectionGeneric_GetConcreteIntVal :: (generic: *SlangReflectionGeneric, valueParam: *SlangReflectionVariable) -> s64 #foreign libslang;

spReflectionGeneric_applySpecializations :: (currGeneric: *SlangReflectionGeneric, generic: *SlangReflectionGeneric) -> *SlangReflectionGeneric #foreign libslang;

/* Get the stage that a variable belongs to (if any).

A variable "belongs" to a specific stage when it is a varying input/output
parameter either defined as part of the parameter list for an entry
point *or* at the global scope of a stage-specific GLSL code file (e.g.,
an `in` parameter in a GLSL `.vs` file belongs to the vertex stage).
*/
spReflectionVariableLayout_getStage :: (var: *SlangReflectionVariableLayout) -> SlangStage #foreign libslang;

spReflectionVariableLayout_getPendingDataLayout :: (var: *SlangReflectionVariableLayout) -> *SlangReflectionVariableLayout #foreign libslang;

// Shader Parameter Reflection
spReflectionParameter_GetBindingIndex :: (parameter: *SlangReflectionParameter) -> u32 #foreign libslang;
spReflectionParameter_GetBindingSpace :: (parameter: *SlangReflectionParameter) -> u32 #foreign libslang;

spIsParameterLocationUsed :: (request: *SlangCompileRequest, entryPointIndex: SlangInt, targetIndex: SlangInt, category: SlangParameterCategory, spaceIndex: SlangUInt, registerIndex: SlangUInt, outUsed: *bool) -> SlangResult #foreign libslang;

// Entry Point Reflection
spReflectionEntryPoint_getName :: (entryPoint: *SlangReflectionEntryPoint) -> *u8 #foreign libslang;

spReflectionEntryPoint_getNameOverride :: (entryPoint: *SlangReflectionEntryPoint) -> *u8 #foreign libslang;

spReflectionEntryPoint_getFunction :: (entryPoint: *SlangReflectionEntryPoint) -> *SlangReflectionFunction #foreign libslang;

spReflectionEntryPoint_getParameterCount :: (entryPoint: *SlangReflectionEntryPoint) -> u32 #foreign libslang;

spReflectionEntryPoint_getParameterByIndex :: (entryPoint: *SlangReflectionEntryPoint, index: u32) -> *SlangReflectionVariableLayout #foreign libslang;

spReflectionEntryPoint_getStage :: (entryPoint: *SlangReflectionEntryPoint) -> SlangStage #foreign libslang;

spReflectionEntryPoint_getComputeThreadGroupSize :: (entryPoint: *SlangReflectionEntryPoint, axisCount: SlangUInt, outSizeAlongAxis: *SlangUInt) -> void #foreign libslang;

spReflectionEntryPoint_getComputeWaveSize :: (entryPoint: *SlangReflectionEntryPoint, outWaveSize: *SlangUInt) -> void #foreign libslang;

spReflectionEntryPoint_usesAnySampleRateInput :: (entryPoint: *SlangReflectionEntryPoint) -> s32 #foreign libslang;

spReflectionEntryPoint_getVarLayout :: (entryPoint: *SlangReflectionEntryPoint) -> *SlangReflectionVariableLayout #foreign libslang;

spReflectionEntryPoint_getResultVarLayout :: (entryPoint: *SlangReflectionEntryPoint) -> *SlangReflectionVariableLayout #foreign libslang;

spReflectionEntryPoint_hasDefaultConstantBuffer :: (entryPoint: *SlangReflectionEntryPoint) -> s32 #foreign libslang;

// SlangReflectionTypeParameter
spReflectionTypeParameter_GetName :: (typeParam: *SlangReflectionTypeParameter) -> *u8 #foreign libslang;

spReflectionTypeParameter_GetIndex :: (typeParam: *SlangReflectionTypeParameter) -> u32 #foreign libslang;
spReflectionTypeParameter_GetConstraintCount :: (typeParam: *SlangReflectionTypeParameter) -> u32 #foreign libslang;

spReflectionTypeParameter_GetConstraintByIndex :: (typeParam: *SlangReflectionTypeParameter, index: u32) -> *SlangReflectionType #foreign libslang;

// Shader Reflection
spReflection_GetParameterCount :: (reflection: *SlangReflection) -> u32 #foreign libslang;
spReflection_GetParameterByIndex :: (reflection: *SlangReflection, index: u32) -> *SlangReflectionParameter #foreign libslang;

spReflection_GetTypeParameterCount :: (reflection: *SlangReflection) -> u32 #foreign libslang;
spReflection_GetTypeParameterByIndex :: (reflection: *SlangReflection, index: u32) -> *SlangReflectionTypeParameter #foreign libslang;

spReflection_FindTypeParameter :: (reflection: *SlangReflection, name: *u8) -> *SlangReflectionTypeParameter #foreign libslang;

spReflection_FindTypeByName :: (reflection: *SlangReflection, name: *u8) -> *SlangReflectionType #foreign libslang;

spReflection_GetTypeLayout :: (reflection: *SlangReflection, reflectionType: *SlangReflectionType, rules: SlangLayoutRules) -> *SlangReflectionTypeLayout #foreign libslang;

spReflection_FindFunctionByName :: (reflection: *SlangReflection, name: *u8) -> *SlangReflectionFunction #foreign libslang;

spReflection_FindFunctionByNameInType :: (reflection: *SlangReflection, reflType: *SlangReflectionType, name: *u8) -> *SlangReflectionFunction #foreign libslang;

spReflection_FindVarByNameInType :: (reflection: *SlangReflection, reflType: *SlangReflectionType, name: *u8) -> *SlangReflectionVariable #foreign libslang;

spReflection_getEntryPointCount :: (reflection: *SlangReflection) -> SlangUInt #foreign libslang;
spReflection_getEntryPointByIndex :: (reflection: *SlangReflection, index: SlangUInt) -> *SlangReflectionEntryPoint #foreign libslang;

spReflection_findEntryPointByName :: (reflection: *SlangReflection, name: *u8) -> *SlangReflectionEntryPoint #foreign libslang;

spReflection_getGlobalConstantBufferBinding :: (reflection: *SlangReflection) -> SlangUInt #foreign libslang;
spReflection_getGlobalConstantBufferSize :: (reflection: *SlangReflection) -> u64 #foreign libslang;

spReflection_specializeType :: (reflection: *SlangReflection, type: *SlangReflectionType, specializationArgCount: SlangInt, specializationArgs: **SlangReflectionType, outDiagnostics: **ISlangBlob) -> *SlangReflectionType #foreign libslang;

spReflection_specializeGeneric :: (inProgramLayout: *SlangReflection, generic: *SlangReflectionGeneric, argCount: SlangInt, argTypes: *SlangReflectionGenericArgType, args: *SlangReflectionGenericArg, outDiagnostics: **ISlangBlob) -> *SlangReflectionGeneric #foreign libslang;

spReflection_isSubType :: (reflection: *SlangReflection, subType: *SlangReflectionType, superType: *SlangReflectionType) -> bool #foreign libslang;

/// Get the number of hashed strings
spReflection_getHashedStringCount :: (reflection: *SlangReflection) -> SlangUInt #foreign libslang;

/// Get a hashed string. The number of chars is written in outCount.
/// The count does *NOT* including terminating 0. The returned string will be 0 terminated.
spReflection_getHashedString :: (reflection: *SlangReflection, index: SlangUInt, outCount: *u64) -> *u8 #foreign libslang;

/// Compute a string hash.
/// Count should *NOT* include terminating zero.
spComputeStringHash :: (chars: *u8, count: u64) -> SlangUInt32 #foreign libslang;

/// Get a type layout representing reflection information for the global-scope prameters.
spReflection_getGlobalParamsTypeLayout :: (reflection: *SlangReflection) -> *SlangReflectionTypeLayout #foreign libslang;

/// Get a variable layout representing reflection information for the global-scope prameters.
spReflection_getGlobalParamsVarLayout :: (reflection: *SlangReflection) -> *SlangReflectionVariableLayout #foreign libslang;

spGetTranslationUnitSource :: (request: *SlangCompileRequest, translationUnitIndex: s32) -> *u8 #foreign libslang;

spReflection_GetSession :: (reflection: *SlangReflection) -> *ISession #foreign libslang "_Z23spReflection_GetSessionP18SlangProgramLayout";

/* @see slang::ICompileRequest::getProgram
*/
spCompileRequest_getProgram :: (request: *SlangCompileRequest, outProgram: **IComponentType) -> SlangResult #foreign libslang;

/* @see slang::ICompileRequest::getProgramWithEntryPoints
*/
spCompileRequest_getProgramWithEntryPoints :: (request: *SlangCompileRequest, outProgram: **IComponentType) -> SlangResult #foreign libslang;

/* @see slang::ICompileRequest::getEntryPoint
*/
spCompileRequest_getEntryPoint :: (request: *SlangCompileRequest, entryPointIndex: SlangInt, outEntryPoint: **IComponentType) -> SlangResult #foreign libslang;

/* @see slang::ICompileRequest::getModule
*/
spCompileRequest_getModule :: (request: *SlangCompileRequest, translationUnitIndex: SlangInt, outModule: **IModule) -> SlangResult #foreign libslang;

/* @see slang::ICompileRequest::getSession
*/
spCompileRequest_getSession :: (request: *SlangCompileRequest, outSession: **ISession) -> SlangResult #foreign libslang;

/* Create a global session, with the built-in core module.

@param apiVersion Pass in SLANG_API_VERSION
@param outGlobalSession (out)The created global session.
*/
slang_createGlobalSession :: (apiVersion: SlangInt, outGlobalSession: **IGlobalSession) -> SlangResult #foreign libslang;

/* Create a global session, but do not set up the core module. The core module can
then be loaded via loadCoreModule or compileCoreModule

@param apiVersion Pass in SLANG_API_VERSION
@param outGlobalSession (out)The created global session that doesn't have a core module setup.

NOTE! API is experimental and not ready for production code
*/
slang_createGlobalSessionWithoutCoreModule :: (apiVersion: SlangInt, outGlobalSession: **IGlobalSession) -> SlangResult #foreign libslang;

/* Returns a blob that contains the serialized core module.
Returns nullptr if there isn't an embedded core module.

NOTE! API is experimental and not ready for production code
*/
slang_getEmbeddedCoreModule :: () -> *ISlangBlob #foreign libslang "_Z27slang_getEmbeddedCoreModulev";

/* Cleanup all global allocations used by Slang, to prevent memory leak detectors from
reporting them as leaks. This function should only be called after all Slang objects
have been released. No other Slang functions such as `createGlobalSession`
should be called after this function.
*/
slang_shutdown :: () -> void #foreign libslang;

#scope_file

#import "Basic"; // For assert


#run {
    {
        instance: CompilerOptionValue;
        assert(((cast(*void)(*instance.kind)) - cast(*void)(*instance)) == 0, "CompilerOptionValue.kind has unexpected offset % instead of 0", ((cast(*void)(*instance.kind)) - cast(*void)(*instance)));
        assert(size_of(type_of(CompilerOptionValue.kind)) == 4, "CompilerOptionValue.kind has unexpected size % instead of 4", size_of(type_of(CompilerOptionValue.kind)));
        assert(((cast(*void)(*instance.intValue0)) - cast(*void)(*instance)) == 4, "CompilerOptionValue.intValue0 has unexpected offset % instead of 4", ((cast(*void)(*instance.intValue0)) - cast(*void)(*instance)));
        assert(size_of(type_of(CompilerOptionValue.intValue0)) == 4, "CompilerOptionValue.intValue0 has unexpected size % instead of 4", size_of(type_of(CompilerOptionValue.intValue0)));
        assert(((cast(*void)(*instance.intValue1)) - cast(*void)(*instance)) == 8, "CompilerOptionValue.intValue1 has unexpected offset % instead of 8", ((cast(*void)(*instance.intValue1)) - cast(*void)(*instance)));
        assert(size_of(type_of(CompilerOptionValue.intValue1)) == 4, "CompilerOptionValue.intValue1 has unexpected size % instead of 4", size_of(type_of(CompilerOptionValue.intValue1)));
        assert(((cast(*void)(*instance.stringValue0)) - cast(*void)(*instance)) == 16, "CompilerOptionValue.stringValue0 has unexpected offset % instead of 16", ((cast(*void)(*instance.stringValue0)) - cast(*void)(*instance)));
        assert(size_of(type_of(CompilerOptionValue.stringValue0)) == 8, "CompilerOptionValue.stringValue0 has unexpected size % instead of 8", size_of(type_of(CompilerOptionValue.stringValue0)));
        assert(((cast(*void)(*instance.stringValue1)) - cast(*void)(*instance)) == 24, "CompilerOptionValue.stringValue1 has unexpected offset % instead of 24", ((cast(*void)(*instance.stringValue1)) - cast(*void)(*instance)));
        assert(size_of(type_of(CompilerOptionValue.stringValue1)) == 8, "CompilerOptionValue.stringValue1 has unexpected size % instead of 8", size_of(type_of(CompilerOptionValue.stringValue1)));
        assert(size_of(CompilerOptionValue) == 32, "CompilerOptionValue has size % instead of 32", size_of(CompilerOptionValue));
    }

    {
        instance: CompilerOptionEntry;
        assert(((cast(*void)(*instance.name)) - cast(*void)(*instance)) == 0, "CompilerOptionEntry.name has unexpected offset % instead of 0", ((cast(*void)(*instance.name)) - cast(*void)(*instance)));
        assert(size_of(type_of(CompilerOptionEntry.name)) == 4, "CompilerOptionEntry.name has unexpected size % instead of 4", size_of(type_of(CompilerOptionEntry.name)));
        assert(((cast(*void)(*instance.value)) - cast(*void)(*instance)) == 8, "CompilerOptionEntry.value has unexpected offset % instead of 8", ((cast(*void)(*instance.value)) - cast(*void)(*instance)));
        assert(size_of(type_of(CompilerOptionEntry.value)) == 32, "CompilerOptionEntry.value has unexpected size % instead of 32", size_of(type_of(CompilerOptionEntry.value)));
        assert(size_of(CompilerOptionEntry) == 40, "CompilerOptionEntry has size % instead of 40", size_of(CompilerOptionEntry));
    }

    assert(size_of(ICompileRequest) == 8, "ICompileRequest has size % instead of 8", size_of(ICompileRequest));

    {
        instance: GenericArgReflection;
        assert(((cast(*void)(*instance.typeVal)) - cast(*void)(*instance)) == 0, "GenericArgReflection.typeVal has unexpected offset % instead of 0", ((cast(*void)(*instance.typeVal)) - cast(*void)(*instance)));
        assert(size_of(type_of(GenericArgReflection.typeVal)) == 8, "GenericArgReflection.typeVal has unexpected size % instead of 8", size_of(type_of(GenericArgReflection.typeVal)));
        assert(((cast(*void)(*instance.intVal)) - cast(*void)(*instance)) == 0, "GenericArgReflection.intVal has unexpected offset % instead of 0", ((cast(*void)(*instance.intVal)) - cast(*void)(*instance)));
        assert(size_of(type_of(GenericArgReflection.intVal)) == 8, "GenericArgReflection.intVal has unexpected size % instead of 8", size_of(type_of(GenericArgReflection.intVal)));
        assert(((cast(*void)(*instance.boolVal)) - cast(*void)(*instance)) == 0, "GenericArgReflection.boolVal has unexpected offset % instead of 0", ((cast(*void)(*instance.boolVal)) - cast(*void)(*instance)));
        assert(size_of(type_of(GenericArgReflection.boolVal)) == 1, "GenericArgReflection.boolVal has unexpected size % instead of 1", size_of(type_of(GenericArgReflection.boolVal)));
        assert(size_of(GenericArgReflection) == 8, "GenericArgReflection has size % instead of 8", size_of(GenericArgReflection));
    }

    assert(size_of(UserAttribute) == 1, "UserAttribute has size % instead of 1", size_of(UserAttribute));

    assert(size_of(TypeReflection) == 1, "TypeReflection has size % instead of 1", size_of(TypeReflection));

    assert(size_of(TypeLayoutReflection) == 1, "TypeLayoutReflection has size % instead of 1", size_of(TypeLayoutReflection));

    assert(size_of(Modifier) == 1, "Modifier has size % instead of 1", size_of(Modifier));

    assert(size_of(VariableReflection) == 1, "VariableReflection has size % instead of 1", size_of(VariableReflection));

    assert(size_of(VariableLayoutReflection) == 1, "VariableLayoutReflection has size % instead of 1", size_of(VariableLayoutReflection));

    assert(size_of(FunctionReflection) == 1, "FunctionReflection has size % instead of 1", size_of(FunctionReflection));

    assert(size_of(GenericReflection) == 1, "GenericReflection has size % instead of 1", size_of(GenericReflection));

    assert(size_of(EntryPointReflection) == 1, "EntryPointReflection has size % instead of 1", size_of(EntryPointReflection));

    assert(size_of(TypeParameterReflection) == 1, "TypeParameterReflection has size % instead of 1", size_of(TypeParameterReflection));

    assert(size_of(ShaderReflection) == 1, "ShaderReflection has size % instead of 1", size_of(ShaderReflection));

    {
        instance: DeclReflection.IteratedList.Iterator;
        assert(((cast(*void)(*instance.parent)) - cast(*void)(*instance)) == 0, "DeclReflection.IteratedList.Iterator.parent has unexpected offset % instead of 0", ((cast(*void)(*instance.parent)) - cast(*void)(*instance)));
        assert(size_of(type_of(DeclReflection.IteratedList.Iterator.parent)) == 8, "DeclReflection.IteratedList.Iterator.parent has unexpected size % instead of 8", size_of(type_of(DeclReflection.IteratedList.Iterator.parent)));
        assert(((cast(*void)(*instance.count)) - cast(*void)(*instance)) == 8, "DeclReflection.IteratedList.Iterator.count has unexpected offset % instead of 8", ((cast(*void)(*instance.count)) - cast(*void)(*instance)));
        assert(size_of(type_of(DeclReflection.IteratedList.Iterator.count)) == 4, "DeclReflection.IteratedList.Iterator.count has unexpected size % instead of 4", size_of(type_of(DeclReflection.IteratedList.Iterator.count)));
        assert(((cast(*void)(*instance.index)) - cast(*void)(*instance)) == 12, "DeclReflection.IteratedList.Iterator.index has unexpected offset % instead of 12", ((cast(*void)(*instance.index)) - cast(*void)(*instance)));
        assert(size_of(type_of(DeclReflection.IteratedList.Iterator.index)) == 4, "DeclReflection.IteratedList.Iterator.index has unexpected size % instead of 4", size_of(type_of(DeclReflection.IteratedList.Iterator.index)));
        assert(size_of(DeclReflection.IteratedList.Iterator) == 16, "DeclReflection.IteratedList.Iterator has size % instead of 16", size_of(DeclReflection.IteratedList.Iterator));
    }

    {
        instance: DeclReflection.IteratedList;
        assert(((cast(*void)(*instance.count)) - cast(*void)(*instance)) == 0, "DeclReflection.IteratedList.count has unexpected offset % instead of 0", ((cast(*void)(*instance.count)) - cast(*void)(*instance)));
        assert(size_of(type_of(DeclReflection.IteratedList.count)) == 4, "DeclReflection.IteratedList.count has unexpected size % instead of 4", size_of(type_of(DeclReflection.IteratedList.count)));
        assert(((cast(*void)(*instance.parent)) - cast(*void)(*instance)) == 8, "DeclReflection.IteratedList.parent has unexpected offset % instead of 8", ((cast(*void)(*instance.parent)) - cast(*void)(*instance)));
        assert(size_of(type_of(DeclReflection.IteratedList.parent)) == 8, "DeclReflection.IteratedList.parent has unexpected size % instead of 8", size_of(type_of(DeclReflection.IteratedList.parent)));
        assert(size_of(DeclReflection.IteratedList) == 16, "DeclReflection.IteratedList has size % instead of 16", size_of(DeclReflection.IteratedList));
    }

    assert(size_of(DeclReflection) == 1, "DeclReflection has size % instead of 1", size_of(DeclReflection));

    assert(size_of(CompileCoreModuleFlag) == 1, "CompileCoreModuleFlag has size % instead of 1", size_of(CompileCoreModuleFlag));

    assert(size_of(IGlobalSession) == 8, "IGlobalSession has size % instead of 8", size_of(IGlobalSession));

    {
        instance: TargetDesc;
        assert(((cast(*void)(*instance.structureSize)) - cast(*void)(*instance)) == 0, "TargetDesc.structureSize has unexpected offset % instead of 0", ((cast(*void)(*instance.structureSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(TargetDesc.structureSize)) == 8, "TargetDesc.structureSize has unexpected size % instead of 8", size_of(type_of(TargetDesc.structureSize)));
        assert(((cast(*void)(*instance.format)) - cast(*void)(*instance)) == 8, "TargetDesc.format has unexpected offset % instead of 8", ((cast(*void)(*instance.format)) - cast(*void)(*instance)));
        assert(size_of(type_of(TargetDesc.format)) == 4, "TargetDesc.format has unexpected size % instead of 4", size_of(type_of(TargetDesc.format)));
        assert(((cast(*void)(*instance.profile)) - cast(*void)(*instance)) == 12, "TargetDesc.profile has unexpected offset % instead of 12", ((cast(*void)(*instance.profile)) - cast(*void)(*instance)));
        assert(size_of(type_of(TargetDesc.profile)) == 4, "TargetDesc.profile has unexpected size % instead of 4", size_of(type_of(TargetDesc.profile)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 16, "TargetDesc.flags has unexpected offset % instead of 16", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(TargetDesc.flags)) == 4, "TargetDesc.flags has unexpected size % instead of 4", size_of(type_of(TargetDesc.flags)));
        assert(((cast(*void)(*instance.floatingPointMode)) - cast(*void)(*instance)) == 20, "TargetDesc.floatingPointMode has unexpected offset % instead of 20", ((cast(*void)(*instance.floatingPointMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(TargetDesc.floatingPointMode)) == 4, "TargetDesc.floatingPointMode has unexpected size % instead of 4", size_of(type_of(TargetDesc.floatingPointMode)));
        assert(((cast(*void)(*instance.lineDirectiveMode)) - cast(*void)(*instance)) == 24, "TargetDesc.lineDirectiveMode has unexpected offset % instead of 24", ((cast(*void)(*instance.lineDirectiveMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(TargetDesc.lineDirectiveMode)) == 4, "TargetDesc.lineDirectiveMode has unexpected size % instead of 4", size_of(type_of(TargetDesc.lineDirectiveMode)));
        assert(((cast(*void)(*instance.forceGLSLScalarBufferLayout)) - cast(*void)(*instance)) == 28, "TargetDesc.forceGLSLScalarBufferLayout has unexpected offset % instead of 28", ((cast(*void)(*instance.forceGLSLScalarBufferLayout)) - cast(*void)(*instance)));
        assert(size_of(type_of(TargetDesc.forceGLSLScalarBufferLayout)) == 1, "TargetDesc.forceGLSLScalarBufferLayout has unexpected size % instead of 1", size_of(type_of(TargetDesc.forceGLSLScalarBufferLayout)));
        assert(((cast(*void)(*instance.compilerOptionEntries)) - cast(*void)(*instance)) == 32, "TargetDesc.compilerOptionEntries has unexpected offset % instead of 32", ((cast(*void)(*instance.compilerOptionEntries)) - cast(*void)(*instance)));
        assert(size_of(type_of(TargetDesc.compilerOptionEntries)) == 8, "TargetDesc.compilerOptionEntries has unexpected size % instead of 8", size_of(type_of(TargetDesc.compilerOptionEntries)));
        assert(((cast(*void)(*instance.compilerOptionEntryCount)) - cast(*void)(*instance)) == 40, "TargetDesc.compilerOptionEntryCount has unexpected offset % instead of 40", ((cast(*void)(*instance.compilerOptionEntryCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(TargetDesc.compilerOptionEntryCount)) == 4, "TargetDesc.compilerOptionEntryCount has unexpected size % instead of 4", size_of(type_of(TargetDesc.compilerOptionEntryCount)));
        assert(size_of(TargetDesc) == 48, "TargetDesc has size % instead of 48", size_of(TargetDesc));
    }

    {
        instance: PreprocessorMacroDesc;
        assert(((cast(*void)(*instance.name)) - cast(*void)(*instance)) == 0, "PreprocessorMacroDesc.name has unexpected offset % instead of 0", ((cast(*void)(*instance.name)) - cast(*void)(*instance)));
        assert(size_of(type_of(PreprocessorMacroDesc.name)) == 8, "PreprocessorMacroDesc.name has unexpected size % instead of 8", size_of(type_of(PreprocessorMacroDesc.name)));
        assert(((cast(*void)(*instance.value)) - cast(*void)(*instance)) == 8, "PreprocessorMacroDesc.value has unexpected offset % instead of 8", ((cast(*void)(*instance.value)) - cast(*void)(*instance)));
        assert(size_of(type_of(PreprocessorMacroDesc.value)) == 8, "PreprocessorMacroDesc.value has unexpected size % instead of 8", size_of(type_of(PreprocessorMacroDesc.value)));
        assert(size_of(PreprocessorMacroDesc) == 16, "PreprocessorMacroDesc has size % instead of 16", size_of(PreprocessorMacroDesc));
    }

    {
        instance: SessionDesc;
        assert(((cast(*void)(*instance.structureSize)) - cast(*void)(*instance)) == 0, "SessionDesc.structureSize has unexpected offset % instead of 0", ((cast(*void)(*instance.structureSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.structureSize)) == 8, "SessionDesc.structureSize has unexpected size % instead of 8", size_of(type_of(SessionDesc.structureSize)));
        assert(((cast(*void)(*instance.targets)) - cast(*void)(*instance)) == 8, "SessionDesc.targets has unexpected offset % instead of 8", ((cast(*void)(*instance.targets)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.targets)) == 8, "SessionDesc.targets has unexpected size % instead of 8", size_of(type_of(SessionDesc.targets)));
        assert(((cast(*void)(*instance.targetCount)) - cast(*void)(*instance)) == 16, "SessionDesc.targetCount has unexpected offset % instead of 16", ((cast(*void)(*instance.targetCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.targetCount)) == 8, "SessionDesc.targetCount has unexpected size % instead of 8", size_of(type_of(SessionDesc.targetCount)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 24, "SessionDesc.flags has unexpected offset % instead of 24", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.flags)) == 4, "SessionDesc.flags has unexpected size % instead of 4", size_of(type_of(SessionDesc.flags)));
        assert(((cast(*void)(*instance.defaultMatrixLayoutMode)) - cast(*void)(*instance)) == 28, "SessionDesc.defaultMatrixLayoutMode has unexpected offset % instead of 28", ((cast(*void)(*instance.defaultMatrixLayoutMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.defaultMatrixLayoutMode)) == 4, "SessionDesc.defaultMatrixLayoutMode has unexpected size % instead of 4", size_of(type_of(SessionDesc.defaultMatrixLayoutMode)));
        assert(((cast(*void)(*instance.searchPaths)) - cast(*void)(*instance)) == 32, "SessionDesc.searchPaths has unexpected offset % instead of 32", ((cast(*void)(*instance.searchPaths)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.searchPaths)) == 8, "SessionDesc.searchPaths has unexpected size % instead of 8", size_of(type_of(SessionDesc.searchPaths)));
        assert(((cast(*void)(*instance.searchPathCount)) - cast(*void)(*instance)) == 40, "SessionDesc.searchPathCount has unexpected offset % instead of 40", ((cast(*void)(*instance.searchPathCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.searchPathCount)) == 8, "SessionDesc.searchPathCount has unexpected size % instead of 8", size_of(type_of(SessionDesc.searchPathCount)));
        assert(((cast(*void)(*instance.preprocessorMacros)) - cast(*void)(*instance)) == 48, "SessionDesc.preprocessorMacros has unexpected offset % instead of 48", ((cast(*void)(*instance.preprocessorMacros)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.preprocessorMacros)) == 8, "SessionDesc.preprocessorMacros has unexpected size % instead of 8", size_of(type_of(SessionDesc.preprocessorMacros)));
        assert(((cast(*void)(*instance.preprocessorMacroCount)) - cast(*void)(*instance)) == 56, "SessionDesc.preprocessorMacroCount has unexpected offset % instead of 56", ((cast(*void)(*instance.preprocessorMacroCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.preprocessorMacroCount)) == 8, "SessionDesc.preprocessorMacroCount has unexpected size % instead of 8", size_of(type_of(SessionDesc.preprocessorMacroCount)));
        assert(((cast(*void)(*instance.fileSystem)) - cast(*void)(*instance)) == 64, "SessionDesc.fileSystem has unexpected offset % instead of 64", ((cast(*void)(*instance.fileSystem)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.fileSystem)) == 8, "SessionDesc.fileSystem has unexpected size % instead of 8", size_of(type_of(SessionDesc.fileSystem)));
        assert(((cast(*void)(*instance.enableEffectAnnotations)) - cast(*void)(*instance)) == 72, "SessionDesc.enableEffectAnnotations has unexpected offset % instead of 72", ((cast(*void)(*instance.enableEffectAnnotations)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.enableEffectAnnotations)) == 1, "SessionDesc.enableEffectAnnotations has unexpected size % instead of 1", size_of(type_of(SessionDesc.enableEffectAnnotations)));
        assert(((cast(*void)(*instance.allowGLSLSyntax)) - cast(*void)(*instance)) == 73, "SessionDesc.allowGLSLSyntax has unexpected offset % instead of 73", ((cast(*void)(*instance.allowGLSLSyntax)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.allowGLSLSyntax)) == 1, "SessionDesc.allowGLSLSyntax has unexpected size % instead of 1", size_of(type_of(SessionDesc.allowGLSLSyntax)));
        assert(((cast(*void)(*instance.compilerOptionEntries)) - cast(*void)(*instance)) == 80, "SessionDesc.compilerOptionEntries has unexpected offset % instead of 80", ((cast(*void)(*instance.compilerOptionEntries)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.compilerOptionEntries)) == 8, "SessionDesc.compilerOptionEntries has unexpected size % instead of 8", size_of(type_of(SessionDesc.compilerOptionEntries)));
        assert(((cast(*void)(*instance.compilerOptionEntryCount)) - cast(*void)(*instance)) == 88, "SessionDesc.compilerOptionEntryCount has unexpected offset % instead of 88", ((cast(*void)(*instance.compilerOptionEntryCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(SessionDesc.compilerOptionEntryCount)) == 4, "SessionDesc.compilerOptionEntryCount has unexpected size % instead of 4", size_of(type_of(SessionDesc.compilerOptionEntryCount)));
        assert(size_of(SessionDesc) == 96, "SessionDesc has size % instead of 96", size_of(SessionDesc));
    }

    assert(size_of(ISession) == 8, "ISession has size % instead of 8", size_of(ISession));

    assert(size_of(IMetadata) == 8, "IMetadata has size % instead of 8", size_of(IMetadata));

    assert(size_of(IComponentType) == 8, "IComponentType has size % instead of 8", size_of(IComponentType));

    assert(size_of(IEntryPoint) == 8, "IEntryPoint has size % instead of 8", size_of(IEntryPoint));

    assert(size_of(ITypeConformance) == 8, "ITypeConformance has size % instead of 8", size_of(ITypeConformance));

    assert(size_of(IModule) == 8, "IModule has size % instead of 8", size_of(IModule));

    assert(size_of(IModulePrecompileService_Experimental) == 8, "IModulePrecompileService_Experimental has size % instead of 8", size_of(IModulePrecompileService_Experimental));

    {
        instance: SpecializationArg;
        assert(((cast(*void)(*instance.kind)) - cast(*void)(*instance)) == 0, "SpecializationArg.kind has unexpected offset % instead of 0", ((cast(*void)(*instance.kind)) - cast(*void)(*instance)));
        assert(size_of(type_of(SpecializationArg.kind)) == 4, "SpecializationArg.kind has unexpected size % instead of 4", size_of(type_of(SpecializationArg.kind)));
        assert(size_of(SpecializationArg) == 16, "SpecializationArg has size % instead of 16", size_of(SpecializationArg));
    }

    {
        instance: SlangUUID;
        assert(((cast(*void)(*instance.data1)) - cast(*void)(*instance)) == 0, "SlangUUID.data1 has unexpected offset % instead of 0", ((cast(*void)(*instance.data1)) - cast(*void)(*instance)));
        assert(size_of(type_of(SlangUUID.data1)) == 4, "SlangUUID.data1 has unexpected size % instead of 4", size_of(type_of(SlangUUID.data1)));
        assert(((cast(*void)(*instance.data2)) - cast(*void)(*instance)) == 4, "SlangUUID.data2 has unexpected offset % instead of 4", ((cast(*void)(*instance.data2)) - cast(*void)(*instance)));
        assert(size_of(type_of(SlangUUID.data2)) == 2, "SlangUUID.data2 has unexpected size % instead of 2", size_of(type_of(SlangUUID.data2)));
        assert(((cast(*void)(*instance.data3)) - cast(*void)(*instance)) == 6, "SlangUUID.data3 has unexpected offset % instead of 6", ((cast(*void)(*instance.data3)) - cast(*void)(*instance)));
        assert(size_of(type_of(SlangUUID.data3)) == 2, "SlangUUID.data3 has unexpected size % instead of 2", size_of(type_of(SlangUUID.data3)));
        assert(((cast(*void)(*instance.data4)) - cast(*void)(*instance)) == 8, "SlangUUID.data4 has unexpected offset % instead of 8", ((cast(*void)(*instance.data4)) - cast(*void)(*instance)));
        assert(size_of(type_of(SlangUUID.data4)) == 8, "SlangUUID.data4 has unexpected size % instead of 8", size_of(type_of(SlangUUID.data4)));
        assert(size_of(SlangUUID) == 16, "SlangUUID has size % instead of 16", size_of(SlangUUID));
    }

    assert(size_of(ISlangUnknown) == 8, "ISlangUnknown has size % instead of 8", size_of(ISlangUnknown));

    assert(size_of(ISlangCastable) == 8, "ISlangCastable has size % instead of 8", size_of(ISlangCastable));

    assert(size_of(ISlangClonable) == 8, "ISlangClonable has size % instead of 8", size_of(ISlangClonable));

    assert(size_of(ISlangBlob) == 8, "ISlangBlob has size % instead of 8", size_of(ISlangBlob));

    {
        instance: SlangTerminatedChars;
        assert(((cast(*void)(*instance.chars)) - cast(*void)(*instance)) == 0, "SlangTerminatedChars.chars has unexpected offset % instead of 0", ((cast(*void)(*instance.chars)) - cast(*void)(*instance)));
        assert(size_of(type_of(SlangTerminatedChars.chars)) == 1, "SlangTerminatedChars.chars has unexpected size % instead of 1", size_of(type_of(SlangTerminatedChars.chars)));
        assert(size_of(SlangTerminatedChars) == 1, "SlangTerminatedChars has size % instead of 1", size_of(SlangTerminatedChars));
    }

    assert(size_of(ISlangFileSystem) == 8, "ISlangFileSystem has size % instead of 8", size_of(ISlangFileSystem));

    assert(size_of(ISlangSharedLibrary_Dep1) == 8, "ISlangSharedLibrary_Dep1 has size % instead of 8", size_of(ISlangSharedLibrary_Dep1));

    assert(size_of(ISlangSharedLibrary) == 8, "ISlangSharedLibrary has size % instead of 8", size_of(ISlangSharedLibrary));

    assert(size_of(ISlangSharedLibraryLoader) == 8, "ISlangSharedLibraryLoader has size % instead of 8", size_of(ISlangSharedLibraryLoader));

    assert(size_of(ISlangFileSystemExt) == 8, "ISlangFileSystemExt has size % instead of 8", size_of(ISlangFileSystemExt));

    assert(size_of(ISlangMutableFileSystem) == 8, "ISlangMutableFileSystem has size % instead of 8", size_of(ISlangMutableFileSystem));

    assert(size_of(ISlangWriter) == 8, "ISlangWriter has size % instead of 8", size_of(ISlangWriter));

    assert(size_of(ISlangProfiler) == 8, "ISlangProfiler has size % instead of 8", size_of(ISlangProfiler));

    {
        instance: SlangReflectionGenericArg;
        assert(((cast(*void)(*instance.typeVal)) - cast(*void)(*instance)) == 0, "SlangReflectionGenericArg.typeVal has unexpected offset % instead of 0", ((cast(*void)(*instance.typeVal)) - cast(*void)(*instance)));
        assert(size_of(type_of(SlangReflectionGenericArg.typeVal)) == 8, "SlangReflectionGenericArg.typeVal has unexpected size % instead of 8", size_of(type_of(SlangReflectionGenericArg.typeVal)));
        assert(((cast(*void)(*instance.intVal)) - cast(*void)(*instance)) == 0, "SlangReflectionGenericArg.intVal has unexpected offset % instead of 0", ((cast(*void)(*instance.intVal)) - cast(*void)(*instance)));
        assert(size_of(type_of(SlangReflectionGenericArg.intVal)) == 8, "SlangReflectionGenericArg.intVal has unexpected size % instead of 8", size_of(type_of(SlangReflectionGenericArg.intVal)));
        assert(((cast(*void)(*instance.boolVal)) - cast(*void)(*instance)) == 0, "SlangReflectionGenericArg.boolVal has unexpected offset % instead of 0", ((cast(*void)(*instance.boolVal)) - cast(*void)(*instance)));
        assert(size_of(type_of(SlangReflectionGenericArg.boolVal)) == 1, "SlangReflectionGenericArg.boolVal has unexpected size % instead of 1", size_of(type_of(SlangReflectionGenericArg.boolVal)));
        assert(size_of(SlangReflectionGenericArg) == 8, "SlangReflectionGenericArg has size % instead of 8", size_of(SlangReflectionGenericArg));
    }
}

